[
    [
        {
            "function_name": "commitStep",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/dices/routers/game_api.py",
            "line_number": 310,
            "source_code": "def commitStep():\n    \"\"\"\n    \u041a\u043e\u043c\u0438\u0438\u0442\u0438\u0442 \u0441\u0442\u0435\u043f (\u0442.\u0435 \u0431\u0440\u043e\u0441\u043e\u043a \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d)\n\n    \u0435\u0441\u043b\u0438 \u0448\u0430\u0433 \u0441 \u0431\u043e\u043b\u0442\u043e\u043c \u0442\u043e \u0434\u0435\u043b\u0430\u0435\u0442\u0441\u044f \u0430\u043d\u043e\u043d\u0441 \u043e \u0441\u043c\u0435\u043d\u0435 \u0438\u0433\u0440\u043e\u043a\u0430\n    \"\"\"\n\n    client_id, is_admin = get_auth_data(request)\n    data = json.loads(request.data)\n\n    room_key = data.get(\"room_key\")\n\n    if not client_id: return resp(None, \"\u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043d\u0435 \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u043e\u0432\u0430\u043d / \u0442\u043e\u043a\u0435\u043d \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u0438 \u0438\u0441\u0442\u0435\u043a\", False, 400)\n\n    if not (room_key := data.get(\"room_key\")):\n        return resp(None, \"\u041a\u043e\u043c\u043d\u0430\u0442\u0430 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430\", False, 400)\n\n    client, room, player = is_player(room_key, client_id)\n\n    step = session.query(Step).filter(Step.room_id == room.id).order_by(desc(Step.time)).first()\n    dices = session.query(Dice).filter(Dice.room_id == room.id, Dice.in_tray == False, Dice.id.in_(data.get(\"dices\", []))).all()\n    score = serial(dices) # \u043f\u0435\u0440\u0435\u043f\u0438\u0441\u0430\u0442\u044c, \u043f\u043e\u0434\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0442\u044c \u0441\u0447\u0435\u0442 \u043d\u0443\u0436\u043d\u043e \u043a\u043e\u0433\u0434\u0430 \u0445\u043e\u0434 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u043f\u043e \u0442\u0440\u0435\u044e\n\n    if score != 0:\n        step.tray_updated = True\n    step.score += score\n    step.stage = 4 if step.is_bolt else 2\n    session.commit()\n\n    announcer.announce(\n        \"commit-step\", \n        {\"step\": as_dict(step)},\n        [p.client.telegram_id for p in room.players]\n    )\n\n    if step.is_bolt:\n        new_player = session.query(Player).filter(Player.room_id == room.id, Player.join_at > player.join_at).first()\n        if not new_player: new_player = session.query(Player).filter(Player.room_id == room.id).order_by(Player.join_at).first()\n\n\n        for dice in room.dices:\n            dice.face = random.randint(1, 5)\n\n        combo = find_combo([d for d in room.dices if not d.in_tray])\n        new_step = Step(is_bolt = len(combo) == 0, player_id = new_player.id, room_id = room.id)\n        session.add(new_step)\n\n        new_player.is_active = True\n        player.is_active = False\n        player.bolts += 1\n        session.commit()\n\n        combo.sort(key=lambda x: -x['score'])\n        combos = []\n        combo_ids = set()\n\n        if len(combo) == 0:\n            new_step.is_bolt = True\n\n        for combo in combo:\n            if len([d for d in combo['dices'] if d.id in combo_ids]) == 0:\n                for d in combo['dices']:\n                    d.in_combo = True\n                    combo_ids.add(d.id)\n                combos.append({\"score\": serial(combo['dices']), \"dices\": [as_dict(d) for d in combo['dices']]})\n\n        announcer.announce(\n            \"change-player\", \n            {\"active_player\": as_dict(new_player, new_player.client), \"player\": as_dict(player, client)},\n            [player.client.telegram_id for player in room.players]\n        )\n\n        announcer.announce(\n            \"new-step\", \n            {\"step\": as_dict(new_step), \"combinations\": combos},\n            [player.client.telegram_id for player in room.players]\n        )\n\n        announcer.announce(\n            \"dices-update\", \n            {\"dices\": [as_dict(d) for d in room.dices]},\n            [player.client.telegram_id for player in room.players]\n        )\n    \n    return resp(None, \"\u0410\u043d\u043e\u043d\u0441 \u0440\u0430\u0437\u043e\u0441\u043b\u0430\u043d\")\n",
            "parameters": [],
            "focused_calls": [
                "order_by"
            ],
            "extend_calls": [
                "def as_dict(*slas) -> dict:\n    result = {}\n    for sla in slas:\n        names = [c.name for c in sla.__table__.columns] if sla.__table__.name != \"clients\" else ['first_name', 'avatar']\n        for c in names:\n            data = getattr(sla, c)\n            if ch(data, [str, bool, int, float]):\n                result[c] = data\n            elif ch(data, [datetime]):\n                result[c] = data.timestamp()\n    return result",
                "def announce(self, event_type: str, data: dict | list = None, targets=None, exclude: set = set()):\n        \"\"\"\n        \u0420\u0430\u0441\u0441\u044b\u043b\u0430\u0435\u0442 \u0430\u043d\u043e\u043d\u0441 \u0441\u043f\u0438\u0441\u043a\u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 / \u0432\u0441\u0435\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c\n        \"\"\"\n        if not targets:\n            for k, q in self.listeners.items():\n                if k in exclude: continue\n                try:\n                    q.put_nowait(json.dumps({\"event\": event_type, \"data\": data}))\n                except queue.Full:\n                    del self.listeners[k]\n        else:\n            for target in targets:\n                if target in exclude: continue\n                if (q := self.listeners.get(target)):\n                    try:\n                        q.put_nowait(json.dumps({\"event\": event_type, \"data\": data}))\n                    except queue.Full:\n                        del self.listeners[target]",
                "def is_player(room_key: str, client_id: int) -> tuple[Client, Room, Player]:\n    client = session.query(Client).filter(Client.telegram_id == client_id).first()\n    if not client: return None, None, None\n\n    room = session.query(Room).filter(Room.room_key == room_key).first()\n    if not room: return None, None, None\n\n    player = session.query(Player).filter(Player.room_id == room.id, Player.client_id == client.id).first()\n    if not player: return None, None, None\n\n    return client, room, player"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/dices/routers/game_api.py:commitStep:310"
        }
    ],
    [
        {
            "function_name": "get_state",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/tools/game.py",
            "line_number": 185,
            "source_code": "def get_state(room: Room, player: Player, fields = []) -> dict:\n\n    result = {}\n\n    if (n := \"room\") in fields: result[n] = as_dict(room)\n    if (n := \"player\") in fields: result[n] = as_dict(player, player.client)\n    if (n := \"active_player\") in fields: \n        active_player = session.query(Player).filter(Player.room_id == room.id, Player.is_active == True).first()\n        result[n] = as_dict(active_player, active_player.client)\n    if (n := \"players\") in fields: result[n] = [as_dict(p, p.client) for p in room.players]\n    if (n := \"steps\") in fields: \n        steps = session.query(Step).filter(Step.stage != 3).order_by(Step.time).all()\n        result[n] = [as_dict(s) for s in steps]\n\n    if (n := \"area\") in fields: result[n] = [as_dict(d) for d in room.dices if not d.in_tray]\n    if (n := \"tray\") in fields: result[n] = [as_dict(d) for d in room.dices if d.in_tray]\n\n    return result\n",
            "parameters": [],
            "focused_calls": [
                "order_by"
            ],
            "extend_calls": [
                "def as_dict(*slas) -> dict:\n    result = {}\n    for sla in slas:\n        names = [c.name for c in sla.__table__.columns] if sla.__table__.name != \"clients\" else ['first_name', 'avatar']\n        for c in names:\n            data = getattr(sla, c)\n            if ch(data, [str, bool, int, float]):\n                result[c] = data\n            elif ch(data, [datetime]):\n                result[c] = data.timestamp()\n    return result"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/tools/game.py:get_state:185"
        },
        {
            "function_name": "getState",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/dices/routers/game_api.py",
            "line_number": 36,
            "source_code": "def getState():\n\n    \"\"\"\n\n    \u041f\u043e\u043b\u043d\u043e\u0435 \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0438\u0433\u0440\u044b\n    :room_key - \u0441\u0441\u044b\u043b\u043a\u0430 \u043d\u0430 \u043a\u043e\u043c\u043d\u0430\u0442\u0443\n\n    \"\"\"\n\n    client_id, is_admin = get_auth_data(request)\n    data = json.loads(request.data)\n\n    room_key = data.get(\"room_key\")\n    fields = data.get(\"fields\")\n\n    if not client_id: \n        return resp(None, \"\u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043d\u0435 \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u043e\u0432\u0430\u043d / \u0442\u043e\u043a\u0435\u043d \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u0438 \u0438\u0441\u0442\u0435\u043a\", False, 400)\n\n    if not (room_key := data.get(\"room_key\")):\n        return resp(None, \"\u041a\u043e\u043c\u043d\u0430\u0442\u0430 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430\", False, 400)\n\n    client, room, player = is_player(room_key, client_id)\n\n    if not client:\n        return resp(None, \"\u0418\u0433\u0440\u043e\u043a \u043d\u0435 \u043f\u0440\u0435\u043d\u0430\u0434\u043b\u0435\u0436\u0438\u0442 \u044d\u0442\u043e\u0439 \u043a\u043e\u043c\u043d\u0430\u0442\u0435, \u043b\u0438\u0431\u043e \u043a\u043e\u043c\u043d\u0430\u0442\u044b \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442\", False, 400)\n\n    if room.stage == 0:\n        return resp(None, \"\u0420\u0430\u043d\u043e, \u0438\u0433\u0440\u0430 \u0435\u0449\u0435 \u043d\u0435 \u043d\u0430\u0447\u0430\u043b\u0430\u0441\u044c\", False, 400)\n\n    active_player = session.query(Player).filter(Player.room_id == room.id, Player.is_active == True).first()\n\n    c = find_combo(room.dices)\n    c.sort(key=lambda x: -x['score'])\n    combos = []\n    combo_ids = set()\n\n    for combo in c:\n        if len([d for d in combo['dices'] if d.id in combo_ids]) == 0:\n            for d in combo['dices']:\n                d.in_combo = True\n                combo_ids.add(d.id)\n            session.commit()\n            combos.append({\"score\": serial(combo['dices']), \"dices\": [as_dict(d) for d in combo['dices']]})\n\n    result = {\n        \"room\": as_dict(room),\n        \"player\": as_dict(player, player.client),\n        \"active_player\": as_dict(active_player, active_player.client),\n        \"players\": [as_dict(p, p.client) for p in room.players],\n        \"steps\": [as_dict(s) for s in room.steps],\n        \"dices\": [as_dict(d) for d in room.dices],\n        \"combinations\": combos\n    }\n    \n    return resp(result, \"\u0422\u0435\u043a\u0443\u0449\u0435\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043a\u043e\u043c\u043d\u0430\u0442\u044b\")\n",
            "parameters": [],
            "focused_calls": [
                "get_state"
            ],
            "extend_calls": [
                "def as_dict(*slas) -> dict:\n    result = {}\n    for sla in slas:\n        names = [c.name for c in sla.__table__.columns] if sla.__table__.name != \"clients\" else ['first_name', 'avatar']\n        for c in names:\n            data = getattr(sla, c)\n            if ch(data, [str, bool, int, float]):\n                result[c] = data\n            elif ch(data, [datetime]):\n                result[c] = data.timestamp()\n    return result",
                "def is_player(room_key: str, client_id: int) -> tuple[Client, Room, Player]:\n    client = session.query(Client).filter(Client.telegram_id == client_id).first()\n    if not client: return None, None, None\n\n    room = session.query(Room).filter(Room.room_key == room_key).first()\n    if not room: return None, None, None\n\n    player = session.query(Player).filter(Player.room_id == room.id, Player.client_id == client.id).first()\n    if not player: return None, None, None\n\n    return client, room, player"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/dices/routers/game_api.py:getState:36"
        }
    ],
    [
        {
            "function_name": "get_state",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/tools/game.py",
            "line_number": 185,
            "source_code": "def get_state(room: Room, player: Player, fields = []) -> dict:\n\n    result = {}\n\n    if (n := \"room\") in fields: result[n] = as_dict(room)\n    if (n := \"player\") in fields: result[n] = as_dict(player, player.client)\n    if (n := \"active_player\") in fields: \n        active_player = session.query(Player).filter(Player.room_id == room.id, Player.is_active == True).first()\n        result[n] = as_dict(active_player, active_player.client)\n    if (n := \"players\") in fields: result[n] = [as_dict(p, p.client) for p in room.players]\n    if (n := \"steps\") in fields: \n        steps = session.query(Step).filter(Step.stage != 3).order_by(Step.time).all()\n        result[n] = [as_dict(s) for s in steps]\n\n    if (n := \"area\") in fields: result[n] = [as_dict(d) for d in room.dices if not d.in_tray]\n    if (n := \"tray\") in fields: result[n] = [as_dict(d) for d in room.dices if d.in_tray]\n\n    return result\n",
            "parameters": [],
            "focused_calls": [
                "order_by"
            ],
            "extend_calls": [
                "def as_dict(*slas) -> dict:\n    result = {}\n    for sla in slas:\n        names = [c.name for c in sla.__table__.columns] if sla.__table__.name != \"clients\" else ['first_name', 'avatar']\n        for c in names:\n            data = getattr(sla, c)\n            if ch(data, [str, bool, int, float]):\n                result[c] = data\n            elif ch(data, [datetime]):\n                result[c] = data.timestamp()\n    return result"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/tools/game.py:get_state:185"
        },
        {
            "function_name": "newStep",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/dices/routers/game_api.py",
            "line_number": 93,
            "source_code": "def newStep():\n    \"\"\"\n    \n    \u0417\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u043d\u043e\u0432\u044b\u0439 \u0445\u043e\u0434, \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u043a\u043e\u0433\u0434\u0430 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0432\u044b\u0431\u0438\u0440\u0430\u0435\u0442 \u043f\u0435\u0440\u0435\u0431\u0440\u043e\u0441\u0438\u0442\u044c \u043a\u043e\u0441\u0442\u0438 \u0432\u043c\u0435\u0441\u0442\u043e \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u044f \u0445\u043e\u0434\u0430\n    :room_key - \u0441\u0441\u044b\u043b\u043a\u0430 \u043d\u0430 \u043a\u043e\u043c\u043d\u0430\u0442\u0443\n\n    returns:\n        step - \u043d\u043e\u0432\u044b\u0439 \u0448\u0430\u0433\n        combo - \u043c\u0430\u0441\u0441\u0438\u0432 \u043a\u043e\u043c\u0431\u0438\u043d\u0430\u0446\u0438\u0439\n    \n    \"\"\"\n\n    client_id, is_admin = get_auth_data(request)\n    data = json.loads(request.data)\n\n    room_key = data.get(\"room_key\")\n\n    if not client_id: \n        return resp(None, \"\u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043d\u0435 \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u043e\u0432\u0430\u043d / \u0442\u043e\u043a\u0435\u043d \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u0438 \u0438\u0441\u0442\u0435\u043a\", False, 400)\n\n    if not (room_key := data.get(\"room_key\")):\n        return resp(None, \"\u041a\u043e\u043c\u043d\u0430\u0442\u0430 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430\", False, 400)\n\n    client, room, player = is_player(room_key, client_id)\n\n    this_step = session.query(Step).filter(Step.room_id == room.id).order_by(desc(Step.time)).first()\n\n    # if not (this_step.tray_updated and this_step.stage == 3) and not (this_step.stage == 4):\n    #     return resp(None, \"\u041d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u043e\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435\", False, 400)\n\n    for dice in room.dices:\n        if not dice.in_combo:\n            dice.face = random.randint(1, 5)\n\n\n    c = find_combo([d for d in room.dices if not d.in_combo])\n    c.sort(key=lambda x: -x['score'])\n    combos = []\n    combo_ids = set()\n\n    step = Step(is_bolt = len(c) == 0, player_id = player.id, room_id = room.id)\n    session.add(step)\n    session.commit()\n\n    if len(c) == 0:\n        step.is_bolt = True\n\n    for combo in c:\n        if len([d for d in combo['dices'] if d.id in combo_ids]) == 0:\n            for d in combo['dices']:\n                d.in_combo = True\n                combo_ids.add(d.id)\n            combos.append({\"score\": serial(combo['dices']), \"dices\": [as_dict(d) for d in combo['dices']]})\n\n    session.commit()\n    \n\n    announcer.announce(\n        \"new-step\", \n        {\"step\": as_dict(step), \"combinations\": combos},\n        [player.client.telegram_id for player in room.players]\n    )\n\n    announcer.announce(\n        \"dices-update\",\n        {\"dices\": [as_dict(d) for d in room.dices]},\n        [player.client.telegram_id for player in room.players]\n    )\n\n\n    return resp(None, \"\u0410\u043d\u043e\u043d\u0441 \u0440\u0430\u0437\u043e\u0441\u043b\u0430\u043d\")\n",
            "parameters": [],
            "focused_calls": [
                "get_state"
            ],
            "extend_calls": [
                "def as_dict(*slas) -> dict:\n    result = {}\n    for sla in slas:\n        names = [c.name for c in sla.__table__.columns] if sla.__table__.name != \"clients\" else ['first_name', 'avatar']\n        for c in names:\n            data = getattr(sla, c)\n            if ch(data, [str, bool, int, float]):\n                result[c] = data\n            elif ch(data, [datetime]):\n                result[c] = data.timestamp()\n    return result",
                "def announce(self, event_type: str, data: dict | list = None, targets=None, exclude: set = set()):\n        \"\"\"\n        \u0420\u0430\u0441\u0441\u044b\u043b\u0430\u0435\u0442 \u0430\u043d\u043e\u043d\u0441 \u0441\u043f\u0438\u0441\u043a\u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 / \u0432\u0441\u0435\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c\n        \"\"\"\n        if not targets:\n            for k, q in self.listeners.items():\n                if k in exclude: continue\n                try:\n                    q.put_nowait(json.dumps({\"event\": event_type, \"data\": data}))\n                except queue.Full:\n                    del self.listeners[k]\n        else:\n            for target in targets:\n                if target in exclude: continue\n                if (q := self.listeners.get(target)):\n                    try:\n                        q.put_nowait(json.dumps({\"event\": event_type, \"data\": data}))\n                    except queue.Full:\n                        del self.listeners[target]",
                "def is_player(room_key: str, client_id: int) -> tuple[Client, Room, Player]:\n    client = session.query(Client).filter(Client.telegram_id == client_id).first()\n    if not client: return None, None, None\n\n    room = session.query(Room).filter(Room.room_key == room_key).first()\n    if not room: return None, None, None\n\n    player = session.query(Player).filter(Player.room_id == room.id, Player.client_id == client.id).first()\n    if not player: return None, None, None\n\n    return client, room, player"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/dices/routers/game_api.py:newStep:93"
        }
    ],
    [
        {
            "function_name": "get_state",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/tools/game.py",
            "line_number": 185,
            "source_code": "def get_state(room: Room, player: Player, fields = []) -> dict:\n\n    result = {}\n\n    if (n := \"room\") in fields: result[n] = as_dict(room)\n    if (n := \"player\") in fields: result[n] = as_dict(player, player.client)\n    if (n := \"active_player\") in fields: \n        active_player = session.query(Player).filter(Player.room_id == room.id, Player.is_active == True).first()\n        result[n] = as_dict(active_player, active_player.client)\n    if (n := \"players\") in fields: result[n] = [as_dict(p, p.client) for p in room.players]\n    if (n := \"steps\") in fields: \n        steps = session.query(Step).filter(Step.stage != 3).order_by(Step.time).all()\n        result[n] = [as_dict(s) for s in steps]\n\n    if (n := \"area\") in fields: result[n] = [as_dict(d) for d in room.dices if not d.in_tray]\n    if (n := \"tray\") in fields: result[n] = [as_dict(d) for d in room.dices if d.in_tray]\n\n    return result\n",
            "parameters": [],
            "focused_calls": [
                "order_by"
            ],
            "extend_calls": [
                "def as_dict(*slas) -> dict:\n    result = {}\n    for sla in slas:\n        names = [c.name for c in sla.__table__.columns] if sla.__table__.name != \"clients\" else ['first_name', 'avatar']\n        for c in names:\n            data = getattr(sla, c)\n            if ch(data, [str, bool, int, float]):\n                result[c] = data\n            elif ch(data, [datetime]):\n                result[c] = data.timestamp()\n    return result"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/tools/game.py:get_state:185"
        },
        {
            "function_name": "endStep",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/dices/routers/game_api.py",
            "line_number": 166,
            "source_code": "def endStep():\n\n    \"\"\"\n    \u0417\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u0442 \u0446\u0438\u043a\u043b \u0431\u0440\u043e\u0441\u043a\u043e\u0432 \u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u0435\u0442 \u0445\u043e\u0434 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u043c\u0443 \u0438\u0433\u0440\u043e\u043a\u0443. \u041e\u0431\u043d\u0443\u043b\u044f\u0435\u0442 \u0442\u0440\u0435\u0439\n    :room_key - \u0441\u0441\u044b\u043b\u043a\u0430 \u043d\u0430 \u043a\u043e\u043c\u043d\u0430\u0442\u0443\n\n    \u0414\u0435\u043b\u0430\u0435\u0442 \u0434\u0432\u0430 \u0430\u043d\u043e\u043d\u0441\u0430 \u043e \u0441\u043c\u0435\u043d\u0435 \u0438\u0433\u0440\u043e\u043a\u0430 \u0438 \u043e \u043d\u043e\u0432\u043e\u043c \u0448\u0430\u0433\u0435\n\n    \"\"\"\n    client_id, is_admin = get_auth_data(request)\n    data = json.loads(request.data)\n\n    room_key = data.get(\"room_key\")\n    fields = data.get(\"fields\")\n\n    if not client_id: \n        return resp(None, \"\u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043d\u0435 \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u043e\u0432\u0430\u043d / \u0442\u043e\u043a\u0435\u043d \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u0438 \u0438\u0441\u0442\u0435\u043a\", False, 400)\n\n    if not (room_key := data.get(\"room_key\")):\n        return resp(None, \"\u041a\u043e\u043c\u043d\u0430\u0442\u0430 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430\", False, 400)\n\n    client, room, player = is_player(room_key, client_id)\n    this_step = session.query(Step).filter(Step.room_id == room.id).order_by(desc(Step.time)).first()\n\n    if not (this_step.tray_updated or not this_step.is_bolt):\n        return resp(None, \"\u041d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u043e\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435\", False, 400)\n    \n    player.score += this_step.score\n    session.commit()\n\n\n    new_player = session.query(Player).filter(Player.room_id == room.id, Player.join_at > player.join_at).first()\n    if not new_player: new_player = session.query(Player).filter(Player.room_id == room.id).order_by(Player.join_at).first()\n    \n    step = Step(player_id = new_player.id, room_id = room.id)\n    session.add(step)\n    session.commit()\n\n    new_player.is_active = True\n    player.is_active = False\n\n    for dice in room.dices:\n        dice.face = random.randint(1, 5)\n        dice.in_combo = False\n        dice.in_tray = False\n\n    c = find_combo(room.dices)\n    c.sort(key=lambda x: -x['score'])\n    combos = []\n    combo_ids = set()\n\n    if len(c) == 0:\n        step.is_bolt = True\n\n    for combo in c:\n        if len([d for d in combo['dices'] if d.id in combo_ids]) == 0:\n            for d in combo['dices']:\n                d.in_combo = True\n                combo_ids.add(d.id)\n            combos.append({\"score\": serial(combo['dices']), \"dices\": [as_dict(d) for d in combo['dices']]})\n\n    session.commit()\n    \n\n    announcer.announce(\n        \"change-player\", \n        {\"active_player\": as_dict(new_player, new_player.client), \"player\": as_dict(player, client)},\n        [player.client.telegram_id for player in room.players]\n    )\n\n    announcer.announce(\n        \"new-step\", \n        {\"step\": as_dict(step), \"combinations\": combos},\n        [player.client.telegram_id for player in room.players]\n    )\n\n    announcer.announce(\n        \"dices-update\",\n        {\"dices\": [as_dict(d) for d in room.dices]},\n        [player.client.telegram_id for player in room.players]\n    )\n\n    return resp(None, \"\u0410\u043d\u043e\u043d\u0441 \u0440\u0430\u0437\u043e\u0441\u043b\u0430\u043d\")\n",
            "parameters": [],
            "focused_calls": [
                "get_state"
            ],
            "extend_calls": [
                "def as_dict(*slas) -> dict:\n    result = {}\n    for sla in slas:\n        names = [c.name for c in sla.__table__.columns] if sla.__table__.name != \"clients\" else ['first_name', 'avatar']\n        for c in names:\n            data = getattr(sla, c)\n            if ch(data, [str, bool, int, float]):\n                result[c] = data\n            elif ch(data, [datetime]):\n                result[c] = data.timestamp()\n    return result",
                "def announce(self, event_type: str, data: dict | list = None, targets=None, exclude: set = set()):\n        \"\"\"\n        \u0420\u0430\u0441\u0441\u044b\u043b\u0430\u0435\u0442 \u0430\u043d\u043e\u043d\u0441 \u0441\u043f\u0438\u0441\u043a\u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 / \u0432\u0441\u0435\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c\n        \"\"\"\n        if not targets:\n            for k, q in self.listeners.items():\n                if k in exclude: continue\n                try:\n                    q.put_nowait(json.dumps({\"event\": event_type, \"data\": data}))\n                except queue.Full:\n                    del self.listeners[k]\n        else:\n            for target in targets:\n                if target in exclude: continue\n                if (q := self.listeners.get(target)):\n                    try:\n                        q.put_nowait(json.dumps({\"event\": event_type, \"data\": data}))\n                    except queue.Full:\n                        del self.listeners[target]",
                "def is_player(room_key: str, client_id: int) -> tuple[Client, Room, Player]:\n    client = session.query(Client).filter(Client.telegram_id == client_id).first()\n    if not client: return None, None, None\n\n    room = session.query(Room).filter(Room.room_key == room_key).first()\n    if not room: return None, None, None\n\n    player = session.query(Player).filter(Player.room_id == room.id, Player.client_id == client.id).first()\n    if not player: return None, None, None\n\n    return client, room, player"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/dices/routers/game_api.py:endStep:166"
        }
    ],
    [
        {
            "function_name": "get_state",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/tools/game.py",
            "line_number": 185,
            "source_code": "def get_state(room: Room, player: Player, fields = []) -> dict:\n\n    result = {}\n\n    if (n := \"room\") in fields: result[n] = as_dict(room)\n    if (n := \"player\") in fields: result[n] = as_dict(player, player.client)\n    if (n := \"active_player\") in fields: \n        active_player = session.query(Player).filter(Player.room_id == room.id, Player.is_active == True).first()\n        result[n] = as_dict(active_player, active_player.client)\n    if (n := \"players\") in fields: result[n] = [as_dict(p, p.client) for p in room.players]\n    if (n := \"steps\") in fields: \n        steps = session.query(Step).filter(Step.stage != 3).order_by(Step.time).all()\n        result[n] = [as_dict(s) for s in steps]\n\n    if (n := \"area\") in fields: result[n] = [as_dict(d) for d in room.dices if not d.in_tray]\n    if (n := \"tray\") in fields: result[n] = [as_dict(d) for d in room.dices if d.in_tray]\n\n    return result\n",
            "parameters": [],
            "focused_calls": [
                "order_by"
            ],
            "extend_calls": [
                "def as_dict(*slas) -> dict:\n    result = {}\n    for sla in slas:\n        names = [c.name for c in sla.__table__.columns] if sla.__table__.name != \"clients\" else ['first_name', 'avatar']\n        for c in names:\n            data = getattr(sla, c)\n            if ch(data, [str, bool, int, float]):\n                result[c] = data\n            elif ch(data, [datetime]):\n                result[c] = data.timestamp()\n    return result"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/tools/game.py:get_state:185"
        },
        {
            "function_name": "trayAdd",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/dices/routers/game_api.py",
            "line_number": 251,
            "source_code": "def trayAdd():\n    \"\"\"\n    \u041f\u0435\u0440\u0435\u043c\u0435\u0449\u0430\u0435\u0442 \u043a\u0443\u0431\u0438\u043a\u0438 \u0432 \u0442\u0440\u0435\u0439\n\n    :dices - list[int] \u043c\u0430\u0441\u0441\u0438\u0432 \u043a\u0443\u0431\u0438\u043a\u043e\u0432 \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u043d\u043e\u0441\u0430 \u0432 \u0442\u0440\u0435\u0439\n    :room_key - \u0441\u0441\u044b\u043b\u043a\u0430 \u043d\u0430 \u043a\u043e\u043c\u043d\u0430\u0442\u0443\n\n    \"\"\"\n\n    client_id, is_admin = get_auth_data(request)\n    data = json.loads(request.data)\n\n    room_key = data.get(\"room_key\")\n\n    if not client_id: return resp(None, \"\u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043d\u0435 \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u043e\u0432\u0430\u043d / \u0442\u043e\u043a\u0435\u043d \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u0438 \u0438\u0441\u0442\u0435\u043a\", False, 400)\n\n    if not (room_key := data.get(\"room_key\")):\n        return resp(None, \"\u041a\u043e\u043c\u043d\u0430\u0442\u0430 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430\", False, 400)\n\n    client, room, player = is_player(room_key, client_id)\n\n    step = session.query(Step).filter(Step.room_id == room.id).order_by(desc(Step.time)).first()\n    dices = session.query(Dice).filter(Dice.room_id == room.id, Dice.in_tray == False, Dice.id.in_(data.get(\"dices\", []))).all()\n\n    score = serial(dices) # \u043f\u0435\u0440\u0435\u043f\u0438\u0441\u0430\u0442\u044c, \u043f\u043e\u0434\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0442\u044c \u0441\u0447\u0435\u0442 \u043d\u0443\u0436\u043d\u043e \u043a\u043e\u0433\u0434\u0430 \u0445\u043e\u0434 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u043f\u043e \u0442\u0440\u0435\u044e\n\n    if score != 0:\n        step.tray_updated = True\n        for d in dices:\n            d.in_tray = True\n    step.score += score\n    session.commit()\n\n    if player.score + step.score >= 1000:\n        room.stage = 2\n        session.commit()\n        announcer.announce(\n            \"redirect\", \n            {\"target\": f\"/results?{room.room_key}\"},\n            [p.client.telegram_id for p in room.players]\n        )\n        \n        return resp(None, \"\u041a\u043e\u043d\u0435\u0446 \u0438\u0433\u0440\u044b\")\n\n    announcer.announce(\n        \"dices-update\", \n        {\"dices\": [as_dict(d) for d in room.dices]},\n        [p.client.telegram_id for p in room.players if p.id != player.id]\n    )\n\n    announcer.announce(\n        \"score-update\", \n        {\"score\": step.score},\n        [p.client.telegram_id for p in room.players]\n    )\n\n    return resp({\"dices\": [as_dict(d) for d in room.dices]}, \"\u0410\u043d\u043e\u043d\u0441 \u0440\u0430\u0437\u043e\u0441\u043b\u0430\u043d\")\n",
            "parameters": [],
            "focused_calls": [
                "get_state"
            ],
            "extend_calls": [
                "def as_dict(*slas) -> dict:\n    result = {}\n    for sla in slas:\n        names = [c.name for c in sla.__table__.columns] if sla.__table__.name != \"clients\" else ['first_name', 'avatar']\n        for c in names:\n            data = getattr(sla, c)\n            if ch(data, [str, bool, int, float]):\n                result[c] = data\n            elif ch(data, [datetime]):\n                result[c] = data.timestamp()\n    return result",
                "def announce(self, event_type: str, data: dict | list = None, targets=None, exclude: set = set()):\n        \"\"\"\n        \u0420\u0430\u0441\u0441\u044b\u043b\u0430\u0435\u0442 \u0430\u043d\u043e\u043d\u0441 \u0441\u043f\u0438\u0441\u043a\u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 / \u0432\u0441\u0435\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c\n        \"\"\"\n        if not targets:\n            for k, q in self.listeners.items():\n                if k in exclude: continue\n                try:\n                    q.put_nowait(json.dumps({\"event\": event_type, \"data\": data}))\n                except queue.Full:\n                    del self.listeners[k]\n        else:\n            for target in targets:\n                if target in exclude: continue\n                if (q := self.listeners.get(target)):\n                    try:\n                        q.put_nowait(json.dumps({\"event\": event_type, \"data\": data}))\n                    except queue.Full:\n                        del self.listeners[target]",
                "def is_player(room_key: str, client_id: int) -> tuple[Client, Room, Player]:\n    client = session.query(Client).filter(Client.telegram_id == client_id).first()\n    if not client: return None, None, None\n\n    room = session.query(Room).filter(Room.room_key == room_key).first()\n    if not room: return None, None, None\n\n    player = session.query(Player).filter(Player.room_id == room.id, Player.client_id == client.id).first()\n    if not player: return None, None, None\n\n    return client, room, player"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/dices/routers/game_api.py:trayAdd:251"
        }
    ],
    [
        {
            "function_name": "get_state",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/tools/game.py",
            "line_number": 185,
            "source_code": "def get_state(room: Room, player: Player, fields = []) -> dict:\n\n    result = {}\n\n    if (n := \"room\") in fields: result[n] = as_dict(room)\n    if (n := \"player\") in fields: result[n] = as_dict(player, player.client)\n    if (n := \"active_player\") in fields: \n        active_player = session.query(Player).filter(Player.room_id == room.id, Player.is_active == True).first()\n        result[n] = as_dict(active_player, active_player.client)\n    if (n := \"players\") in fields: result[n] = [as_dict(p, p.client) for p in room.players]\n    if (n := \"steps\") in fields: \n        steps = session.query(Step).filter(Step.stage != 3).order_by(Step.time).all()\n        result[n] = [as_dict(s) for s in steps]\n\n    if (n := \"area\") in fields: result[n] = [as_dict(d) for d in room.dices if not d.in_tray]\n    if (n := \"tray\") in fields: result[n] = [as_dict(d) for d in room.dices if d.in_tray]\n\n    return result\n",
            "parameters": [],
            "focused_calls": [
                "order_by"
            ],
            "extend_calls": [
                "def as_dict(*slas) -> dict:\n    result = {}\n    for sla in slas:\n        names = [c.name for c in sla.__table__.columns] if sla.__table__.name != \"clients\" else ['first_name', 'avatar']\n        for c in names:\n            data = getattr(sla, c)\n            if ch(data, [str, bool, int, float]):\n                result[c] = data\n            elif ch(data, [datetime]):\n                result[c] = data.timestamp()\n    return result"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/tools/game.py:get_state:185"
        },
        {
            "function_name": "commitStep",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/dices/routers/game_api.py",
            "line_number": 310,
            "source_code": "def commitStep():\n    \"\"\"\n    \u041a\u043e\u043c\u0438\u0438\u0442\u0438\u0442 \u0441\u0442\u0435\u043f (\u0442.\u0435 \u0431\u0440\u043e\u0441\u043e\u043a \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d)\n\n    \u0435\u0441\u043b\u0438 \u0448\u0430\u0433 \u0441 \u0431\u043e\u043b\u0442\u043e\u043c \u0442\u043e \u0434\u0435\u043b\u0430\u0435\u0442\u0441\u044f \u0430\u043d\u043e\u043d\u0441 \u043e \u0441\u043c\u0435\u043d\u0435 \u0438\u0433\u0440\u043e\u043a\u0430\n    \"\"\"\n\n    client_id, is_admin = get_auth_data(request)\n    data = json.loads(request.data)\n\n    room_key = data.get(\"room_key\")\n\n    if not client_id: return resp(None, \"\u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043d\u0435 \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u043e\u0432\u0430\u043d / \u0442\u043e\u043a\u0435\u043d \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u0438 \u0438\u0441\u0442\u0435\u043a\", False, 400)\n\n    if not (room_key := data.get(\"room_key\")):\n        return resp(None, \"\u041a\u043e\u043c\u043d\u0430\u0442\u0430 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430\", False, 400)\n\n    client, room, player = is_player(room_key, client_id)\n\n    step = session.query(Step).filter(Step.room_id == room.id).order_by(desc(Step.time)).first()\n    dices = session.query(Dice).filter(Dice.room_id == room.id, Dice.in_tray == False, Dice.id.in_(data.get(\"dices\", []))).all()\n    score = serial(dices) # \u043f\u0435\u0440\u0435\u043f\u0438\u0441\u0430\u0442\u044c, \u043f\u043e\u0434\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0442\u044c \u0441\u0447\u0435\u0442 \u043d\u0443\u0436\u043d\u043e \u043a\u043e\u0433\u0434\u0430 \u0445\u043e\u0434 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u043f\u043e \u0442\u0440\u0435\u044e\n\n    if score != 0:\n        step.tray_updated = True\n    step.score += score\n    step.stage = 4 if step.is_bolt else 2\n    session.commit()\n\n    announcer.announce(\n        \"commit-step\", \n        {\"step\": as_dict(step)},\n        [p.client.telegram_id for p in room.players]\n    )\n\n    if step.is_bolt:\n        new_player = session.query(Player).filter(Player.room_id == room.id, Player.join_at > player.join_at).first()\n        if not new_player: new_player = session.query(Player).filter(Player.room_id == room.id).order_by(Player.join_at).first()\n\n\n        for dice in room.dices:\n            dice.face = random.randint(1, 5)\n\n        combo = find_combo([d for d in room.dices if not d.in_tray])\n        new_step = Step(is_bolt = len(combo) == 0, player_id = new_player.id, room_id = room.id)\n        session.add(new_step)\n\n        new_player.is_active = True\n        player.is_active = False\n        player.bolts += 1\n        session.commit()\n\n        combo.sort(key=lambda x: -x['score'])\n        combos = []\n        combo_ids = set()\n\n        if len(combo) == 0:\n            new_step.is_bolt = True\n\n        for combo in combo:\n            if len([d for d in combo['dices'] if d.id in combo_ids]) == 0:\n                for d in combo['dices']:\n                    d.in_combo = True\n                    combo_ids.add(d.id)\n                combos.append({\"score\": serial(combo['dices']), \"dices\": [as_dict(d) for d in combo['dices']]})\n\n        announcer.announce(\n            \"change-player\", \n            {\"active_player\": as_dict(new_player, new_player.client), \"player\": as_dict(player, client)},\n            [player.client.telegram_id for player in room.players]\n        )\n\n        announcer.announce(\n            \"new-step\", \n            {\"step\": as_dict(new_step), \"combinations\": combos},\n            [player.client.telegram_id for player in room.players]\n        )\n\n        announcer.announce(\n            \"dices-update\", \n            {\"dices\": [as_dict(d) for d in room.dices]},\n            [player.client.telegram_id for player in room.players]\n        )\n    \n    return resp(None, \"\u0410\u043d\u043e\u043d\u0441 \u0440\u0430\u0437\u043e\u0441\u043b\u0430\u043d\")\n",
            "parameters": [],
            "focused_calls": [
                "get_state"
            ],
            "extend_calls": [
                "def as_dict(*slas) -> dict:\n    result = {}\n    for sla in slas:\n        names = [c.name for c in sla.__table__.columns] if sla.__table__.name != \"clients\" else ['first_name', 'avatar']\n        for c in names:\n            data = getattr(sla, c)\n            if ch(data, [str, bool, int, float]):\n                result[c] = data\n            elif ch(data, [datetime]):\n                result[c] = data.timestamp()\n    return result",
                "def announce(self, event_type: str, data: dict | list = None, targets=None, exclude: set = set()):\n        \"\"\"\n        \u0420\u0430\u0441\u0441\u044b\u043b\u0430\u0435\u0442 \u0430\u043d\u043e\u043d\u0441 \u0441\u043f\u0438\u0441\u043a\u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 / \u0432\u0441\u0435\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c\n        \"\"\"\n        if not targets:\n            for k, q in self.listeners.items():\n                if k in exclude: continue\n                try:\n                    q.put_nowait(json.dumps({\"event\": event_type, \"data\": data}))\n                except queue.Full:\n                    del self.listeners[k]\n        else:\n            for target in targets:\n                if target in exclude: continue\n                if (q := self.listeners.get(target)):\n                    try:\n                        q.put_nowait(json.dumps({\"event\": event_type, \"data\": data}))\n                    except queue.Full:\n                        del self.listeners[target]",
                "def is_player(room_key: str, client_id: int) -> tuple[Client, Room, Player]:\n    client = session.query(Client).filter(Client.telegram_id == client_id).first()\n    if not client: return None, None, None\n\n    room = session.query(Room).filter(Room.room_key == room_key).first()\n    if not room: return None, None, None\n\n    player = session.query(Player).filter(Player.room_id == room.id, Player.client_id == client.id).first()\n    if not player: return None, None, None\n\n    return client, room, player"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/dices/routers/game_api.py:commitStep:310"
        }
    ],
    [
        {
            "function_name": "commitStep",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/dices/routers/game_api.py",
            "line_number": 310,
            "source_code": "def commitStep():\n    \"\"\"\n    \u041a\u043e\u043c\u0438\u0438\u0442\u0438\u0442 \u0441\u0442\u0435\u043f (\u0442.\u0435 \u0431\u0440\u043e\u0441\u043e\u043a \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d)\n\n    \u0435\u0441\u043b\u0438 \u0448\u0430\u0433 \u0441 \u0431\u043e\u043b\u0442\u043e\u043c \u0442\u043e \u0434\u0435\u043b\u0430\u0435\u0442\u0441\u044f \u0430\u043d\u043e\u043d\u0441 \u043e \u0441\u043c\u0435\u043d\u0435 \u0438\u0433\u0440\u043e\u043a\u0430\n    \"\"\"\n\n    client_id, is_admin = get_auth_data(request)\n    data = json.loads(request.data)\n\n    room_key = data.get(\"room_key\")\n\n    if not client_id: return resp(None, \"\u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043d\u0435 \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u043e\u0432\u0430\u043d / \u0442\u043e\u043a\u0435\u043d \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u0438 \u0438\u0441\u0442\u0435\u043a\", False, 400)\n\n    if not (room_key := data.get(\"room_key\")):\n        return resp(None, \"\u041a\u043e\u043c\u043d\u0430\u0442\u0430 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u0430\", False, 400)\n\n    client, room, player = is_player(room_key, client_id)\n\n    step = session.query(Step).filter(Step.room_id == room.id).order_by(desc(Step.time)).first()\n    dices = session.query(Dice).filter(Dice.room_id == room.id, Dice.in_tray == False, Dice.id.in_(data.get(\"dices\", []))).all()\n    score = serial(dices) # \u043f\u0435\u0440\u0435\u043f\u0438\u0441\u0430\u0442\u044c, \u043f\u043e\u0434\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0442\u044c \u0441\u0447\u0435\u0442 \u043d\u0443\u0436\u043d\u043e \u043a\u043e\u0433\u0434\u0430 \u0445\u043e\u0434 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f \u043f\u043e \u0442\u0440\u0435\u044e\n\n    if score != 0:\n        step.tray_updated = True\n    step.score += score\n    step.stage = 4 if step.is_bolt else 2\n    session.commit()\n\n    announcer.announce(\n        \"commit-step\", \n        {\"step\": as_dict(step)},\n        [p.client.telegram_id for p in room.players]\n    )\n\n    if step.is_bolt:\n        new_player = session.query(Player).filter(Player.room_id == room.id, Player.join_at > player.join_at).first()\n        if not new_player: new_player = session.query(Player).filter(Player.room_id == room.id).order_by(Player.join_at).first()\n\n\n        for dice in room.dices:\n            dice.face = random.randint(1, 5)\n\n        combo = find_combo([d for d in room.dices if not d.in_tray])\n        new_step = Step(is_bolt = len(combo) == 0, player_id = new_player.id, room_id = room.id)\n        session.add(new_step)\n\n        new_player.is_active = True\n        player.is_active = False\n        player.bolts += 1\n        session.commit()\n\n        combo.sort(key=lambda x: -x['score'])\n        combos = []\n        combo_ids = set()\n\n        if len(combo) == 0:\n            new_step.is_bolt = True\n\n        for combo in combo:\n            if len([d for d in combo['dices'] if d.id in combo_ids]) == 0:\n                for d in combo['dices']:\n                    d.in_combo = True\n                    combo_ids.add(d.id)\n                combos.append({\"score\": serial(combo['dices']), \"dices\": [as_dict(d) for d in combo['dices']]})\n\n        announcer.announce(\n            \"change-player\", \n            {\"active_player\": as_dict(new_player, new_player.client), \"player\": as_dict(player, client)},\n            [player.client.telegram_id for player in room.players]\n        )\n\n        announcer.announce(\n            \"new-step\", \n            {\"step\": as_dict(new_step), \"combinations\": combos},\n            [player.client.telegram_id for player in room.players]\n        )\n\n        announcer.announce(\n            \"dices-update\", \n            {\"dices\": [as_dict(d) for d in room.dices]},\n            [player.client.telegram_id for player in room.players]\n        )\n    \n    return resp(None, \"\u0410\u043d\u043e\u043d\u0441 \u0440\u0430\u0437\u043e\u0441\u043b\u0430\u043d\")\n",
            "parameters": [],
            "focused_calls": [
                "order_by"
            ],
            "extend_calls": [
                "def as_dict(*slas) -> dict:\n    result = {}\n    for sla in slas:\n        names = [c.name for c in sla.__table__.columns] if sla.__table__.name != \"clients\" else ['first_name', 'avatar']\n        for c in names:\n            data = getattr(sla, c)\n            if ch(data, [str, bool, int, float]):\n                result[c] = data\n            elif ch(data, [datetime]):\n                result[c] = data.timestamp()\n    return result",
                "def announce(self, event_type: str, data: dict | list = None, targets=None, exclude: set = set()):\n        \"\"\"\n        \u0420\u0430\u0441\u0441\u044b\u043b\u0430\u0435\u0442 \u0430\u043d\u043e\u043d\u0441 \u0441\u043f\u0438\u0441\u043a\u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 / \u0432\u0441\u0435\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u043c\n        \"\"\"\n        if not targets:\n            for k, q in self.listeners.items():\n                if k in exclude: continue\n                try:\n                    q.put_nowait(json.dumps({\"event\": event_type, \"data\": data}))\n                except queue.Full:\n                    del self.listeners[k]\n        else:\n            for target in targets:\n                if target in exclude: continue\n                if (q := self.listeners.get(target)):\n                    try:\n                        q.put_nowait(json.dumps({\"event\": event_type, \"data\": data}))\n                    except queue.Full:\n                        del self.listeners[target]",
                "def is_player(room_key: str, client_id: int) -> tuple[Client, Room, Player]:\n    client = session.query(Client).filter(Client.telegram_id == client_id).first()\n    if not client: return None, None, None\n\n    room = session.query(Room).filter(Room.room_key == room_key).first()\n    if not room: return None, None, None\n\n    player = session.query(Player).filter(Player.room_id == room.id, Player.client_id == client.id).first()\n    if not player: return None, None, None\n\n    return client, room, player"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2019-7548/dices-master/dices/routers/game_api.py:commitStep:310"
        }
    ]
]
