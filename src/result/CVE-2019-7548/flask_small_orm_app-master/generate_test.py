from contextlib import contextmanager

import pytest
from flask import Flask, request, url_for
from flask_login import LoginManager, current_user, login_user
from werkzeug.security import generate_password_hash
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
import os

# 测试数据库配置
from app import app
from db import get_session
from models import Task, User

TEST_DB_URL = "postgresql://testuser:testpass@localhost:5432/testdb"

@pytest.fixture(scope='module')
def test_app():
    # 创建测试应用
    app.config['TESTING'] = True
    app.config['WTF_CSRF_ENABLED'] = False
    app.config['SQLALCHEMY_DATABASE_URI'] = TEST_DB_URL

    # 创建测试数据库引擎
    engine = create_engine(TEST_DB_URL)
    TestingSession = sessionmaker(bind=engine)

    # 重写get_session使用测试数据库
    @contextmanager
    def test_get_session():
        session = TestingSession()
        try:
            yield session
            session.commit()
        except Exception:
            session.rollback()
            raise
        finally:
            session.close()

    # 临时替换原get_session
    original_get_session = get_session
    app.get_session = test_get_session

    # 创建测试表
    with app.app_context():
        from models import Base
        Base.metadata.create_all(engine)

        # 添加测试数据
        session = test_get_session()
        try:
            # 添加测试用户
            test_user = User(
                username='testuser',
                password=generate_password_hash('testpass')
            )
            session.add(test_user)

            # 添加测试任务
            tasks = [
                Task(name='Urgent', priority=1, user_id=1),
                Task(name='Normal', priority=2, user_id=1),
                Task(name='Low', priority=3, user_id=1)
            ]
            session.add_all(tasks)
            session.commit()
        finally:
            session.close()

    yield app

    # 测试后清理
    with app.app_context():
        Base.metadata.drop_all(engine)
    app.get_session = original_get_session

@pytest.fixture
def client(test_app):
    return test_app.test_client()

@pytest.fixture
def authenticated_client(client):
    # 登录测试用户
    with client:
        client.post('/login', data={
            'username': 'testuser',
            'password': 'testpass'
        }, follow_redirects=True)
        yield client

def test_index_normal_usage(authenticated_client):
    """测试正常排序功能"""
    # 测试默认排序
    response = authenticated_client.get('/index/')
    assert response.status_code == 200
    assert b'Urgent' in response.data

    # 测试按priority排序
    response = authenticated_client.get('/index/?sort_by=priority')
    assert response.status_code == 200

    # 测试按name排序
    response = authenticated_client.get('/index/?sort_by=name')
    assert response.status_code == 200

def test_index_sql_injection(authenticated_client):
    """测试SQL注入漏洞"""
    injection_tests = [
        ("id; SELECT * FROM user --", "用户表查询注入"),
        ("(CASE WHEN (1=1) THEN priority ELSE name END)", "条件逻辑注入"),
        ("id UNION SELECT null,null,null,null,null,null FROM task --", "联合查询注入"),
        ("id; DROP TABLE task --", "破坏性注入尝试"),
        ("(SELECT COUNT(*) FROM user)", "子查询注入")
    ]

    for sort_by, description in injection_tests:
        print(f"测试注入: {description}")
        response = authenticated_client.get(f'/index/?sort_by={sort_by}')
        # 如果返回200，说明注入可能成功
        assert response.status_code == 200, f"注入测试失败: {description}"

        # 检查是否返回了异常数据
        if "UNION" in sort_by:
            assert b'Urgent' not in response.data, "可能返回了联合查询结果"
