PycharmProjects/PyVul/venv/lib/python3.9/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020
  warnings.warn(
processing test...  1
def index():
    with get_session() as session:
        user_tasks = session.query(Task).filter_by(user_id=current_user.id)
        sort_by = request.args.get('sort_by', default='priority')
        sorted_tasks =  user_tasks.order_by(sort_by).all()
        return render_template(
            'index.html',
            sorted_tasks=sorted_tasks
        )

To verify the SQL injection vulnerability in the `sort_by` parameter, we can create a test that checks if arbitrary SQL expressions can alter the task order. Here's a complete unit test using Flask's test client and real database interactions:

```python
import pytest
from flask import url_for
from bs4 import BeautifulSoup
from your_application import create_app
from your_application.models import User, Task, get_session

def test_sql_injection_via_sort_by():
    # Initialize the Flask application with test configuration
    app = create_app()
    app.config['TESTING'] = True
    app.config['WTF_CSRF_ENABLED'] = False  # Disable CSRF protection for testing

    with app.test_client() as client:
        with app.app_context():
            # Set up the database session
            session = get_session()

            # Create a test user
            test_user = User(username='test_user', password='test_pass')
            session.add(test_user)
            session.commit()

            # Create test tasks with different priorities and titles
            task1 = Task(user_id=test_user.id, priority=1, title='Task 1 - Low Priority')
            task2 = Task(user_id=test_user.id, priority=3, title='Task 3 - High Priority')
            task3 = Task(user_id=test_user.id, priority=2, title='Task 2 - Medium Priority')
            session.add_all([task1, task2, task3])
            session.commit()

        # Simulate user login
        client.post('/login', data={
            'username': 'test_user',
            'password': 'test_pass'
        }, follow_redirects=True)

        # Test default sorting by priority (ascending)
        response = client.get(url_for('index'))
        soup = BeautifulSoup(response.data, 'html.parser')
        task_titles = [t.get_text(strip=True) for t in soup.select('.task-title')]
        assert task_titles == ['Task 1 - Low Priority', 'Task 2 - Medium Priority', 'Task 3 - High Priority']

        # Test SQL injection via sort_by parameter (priority descending)
        response = client.get(url_for('index', sort_by='priority DESC'))
        soup = BeautifulSoup(response.data, 'html.parser')
        task_titles = [t.get_text(strip=True) for t in soup.select('.task-title')]
        assert task_titles == ['Task 3 - High Priority', 'Task 2 - Medium Priority', 'Task 1 - Low Priority']

        # Test SQL injection with CASE statement (sort by id if priority is even)
        malicious_param = 'CASE WHEN priority % 2 = 0 THEN id ELSE priority END DESC'
        response = client.get(url_for('index', sort_by=malicious_param))
        soup = BeautifulSoup(response.data, 'html.parser')
        task_titles = [t.get_text(strip=True) for t in soup.select('.task-title')]

        # Verify custom sorting logic was applied
        expected_order = ['Task 3 - High Priority', 'Task 1 - Low Priority', 'Task 2 - Medium Priority']
        assert task_titles == expected_order, "SQL injection via CASE statement altered sort order"

        # Test secondary injection (sort by different column)
        response = client.get(url_for('index', sort_by='title'))
        soup = BeautifulSoup(response.data, 'html.parser')
        task_titles = [t.get_text(strip=True) for t in soup.select('.task-title')]
        assert task_titles == ['Task 1 - Low Priority', 'Task 2 - Medium Priority', 'Task 3 - High Priority']
```

**Key Verification Points:**

1. **Basic Order Verification:** Confirms normal sorting works as expected
2. **Direct SQL Injection:** Shows we can reverse sort order using SQL keywords (`DESC`)
3. **Complex Expression Injection:** Demonstrates arbitrary SQL expressions using `CASE`
4. **Column Manipulation:** Verifies we can sort by different columns than intended

**Implementation Notes:**
- Replace `your_application` with your actual application module name
- Update HTML selectors (`.task-title`) to match your template structure
- Ensure test database is properly configured (SQLite in-memory recommended)
- Add proper teardown methods to clean database after tests if needed

This test demonstrates that an attacker can:
1. Control sort direction through SQL keywords
2. Use complex SQL expressions to create custom sort logic
3. Access different columns than originally intended

These capabilities confirm the presence of a SQL injection vulnerability in the `sort_by` parameter handling.
processing test...  2
def index():
    with get_session() as session:
        user_tasks = session.query(Task).filter_by(user_id=current_user.id)
        sort_by = request.args.get('sort_by', default='priority')
        sorted_tasks =  user_tasks.order_by(sort_by).all()
        return render_template(
            'index.html',
            sorted_tasks=sorted_tasks
        )

To verify the SQL injection vulnerability in the `sort_by` parameter of the `/index/` endpoint, we construct a test that checks if the order of results can be manipulated using a crafted SQL payload. Here's the complete unit test:

```python
import unittest
from flask import Flask, url_for
from flask_sqlalchemy import SQLAlchemy
from app import app, get_session, Task, User
from bs4 import BeautifulSoup

class TestSQLInjectionIndex(unittest.TestCase):
    def setUp(self):
        self.app = app
        self.app.config['TESTING'] = True
        self.app.config['WTF_CSRF_ENABLED'] = False
        self.app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
        self.client = self.app.test_client()

        # Set up in-memory database
        with self.app.app_context():
            db = SQLAlchemy(self.app)
            db.create_all()

            # Create test user
            self.user = User(username='testuser', password='testpass')
            session = get_session()
            session.add(self.user)
            session.commit()
            self.user_id = self.user.id

            # Create test tasks
            task1 = Task(user_id=self.user_id, priority=1, date='2023-01-02')
            task2 = Task(user_id=self.user_id, priority=2, date='2023-01-01')
            session.add_all([task1, task2])
            session.commit()

    def login(self):
        # Log in the test user
        return self.client.post('/login', data={
            'username': 'testuser',
            'password': 'testpass'
        }, follow_redirects=True)

    def test_sql_injection_via_sort_by(self):
        # Perform login
        self.login()

        # Test with TRUE condition (sort by priority)
        true_payload = 'CASE%20WHEN%201%3D1%20THEN%20priority%20ELSE%20date%20END'
        response = self.client.get(f'/index/?sort_by={true_payload}')
        self.assertEqual(response.status_code, 200)

        # Parse tasks from response
        soup = BeautifulSoup(response.data, 'html.parser')
        tasks = soup.find_all('div', class_='task-priority')  # Adjust based on actual HTML

        # Verify order is by priority (1, 2)
        priorities = [int(task.text.strip()) for task in tasks]
        self.assertEqual(priorities, [1, 2])

        # Test with FALSE condition (sort by date)
        false_payload = 'CASE%20WHEN%201%3D0%20THEN%20priority%20ELSE%20date%20END'
        response = self.client.get(f'/index/?sort_by={false_payload}')
        self.assertEqual(response.status_code, 200)

        # Parse tasks from response
        soup = BeautifulSoup(response.data, 'html.parser')
        dates = soup.find_all('div', class_='task-date')  # Adjust based on actual HTML

        # Verify order is by date (2023-01-01 comes first)
        date_values = [date.text.strip() for date in dates]
        self.assertEqual(date_values, ['2023-01-01', '2023-01-02'])

if __name__ == '__main__':
    unittest.main()
```

**Test Explanation:**

1. **Database Setup:** Uses an in-memory SQLite database to create test user and tasks with known priorities and dates.

2. **Authentication:** Logs in the test user before making requests to the protected endpoint.

3. **Payload Construction:**
   - TRUE condition payload: Forces sorting by `priority` column
   - FALSE condition payload: Forces sorting by `date` column

4. **Order Verification:**
   - Checks task order when sorted by priority (expected: 1, 2)
   - Checks task order when sorted by date (expected: 2023-01-01, 2023-01-02)

**Key Indicators of Vulnerability:**
- If both test cases pass, it confirms the application executes raw SQL from user input
- The ability to change sort order via SQL expressions proves injection capability

**Note:** Adjust HTML parsing logic (`task-priority`, `task-date` classes) based on your actual template structure. This test demonstrates successful SQL injection by observing changes in application behavior from crafted inputs.
processing test...  3
def index():
    with get_session() as session:
        user_tasks = session.query(Task).filter_by(user_id=current_user.id)
        sort_by = request.args.get('sort_by', default='priority')
        sorted_tasks =  user_tasks.order_by(sort_by).all()
        return render_template(
            'index.html',
            sorted_tasks=sorted_tasks
        )

To verify the SQL injection vulnerability in the `sort_by` parameter of the `/index/` route, we create a test that checks if the order of tasks can be manipulated using a crafted SQL expression.

```python
import pytest
from flask import url_for
from bs4 import BeautifulSoup
from your_app import create_app
from your_app.models import db, User, Task

@pytest.fixture
def app():
    app = create_app(config_class='TestingConfig')
    with app.app_context():
        db.create_all()
        yield app
        db.drop_all()

@pytest.fixture
def client(app):
    return app.test_client()

def test_sql_injection_via_sort_by(client, app):
    # Setup test user and tasks
    with app.app_context():
        # Create test user
        user = User(username='testuser', password='testpass')
        db.session.add(user)
        db.session.commit()

        # Create test tasks with specific priorities and titles
        task1 = Task(user_id=user.id, priority=1, title='B')
        task2 = Task(user_id=user.id, priority=2, title='A')
        db.session.add_all([task1, task2])
        db.session.commit()

    # Simulate user login
    client.post('/login', data={
        'username': 'testuser',
        'password': 'testpass'
    }, follow_redirects=True)

    # Baseline request with valid sorting (priority ascending)
    response_baseline = client.get(url_for('index', sort_by='priority'))
    assert response_baseline.status_code == 200

    # Extract task order from baseline response
    soup_baseline = BeautifulSoup(response_baseline.data, 'html.parser')
    tasks_baseline = [task.text.strip() for task in soup_baseline.select('.task-title')]

    # Expected baseline order: tasks sorted by priority (1, 2) → titles ['B', 'A']
    assert tasks_baseline == ['B', 'A']

    # Malicious request with SQL injection in sort_by parameter
    # Injects CASE expression to force sorting by title instead of priority
    sql_injection = "(CASE WHEN (1=1) THEN title ELSE priority END)"
    response_injected = client.get(url_for('index', sort_by=sql_injection))

    # Check if the application processed the malicious input without errors
    assert response_injected.status_code == 200

    # Extract task order from injected response
    soup_injected = BeautifulSoup(response_injected.data, 'html.parser')
    tasks_injected = [task.text.strip() for task in soup_injected.select('.task-title')]

    # If vulnerable, tasks are sorted by title → ['A', 'B']
    # If not vulnerable, order remains ['B', 'A'] or the request fails
    assert tasks_injected == ['A', 'B'], "SQL Injection vulnerability detected: Task order manipulated by injected SQL."
```

**Explanation:**

1. **Test Setup**:
   - Creates a test user and two tasks with known titles and priorities.
   - Logs in the test user to access the `@login_required` route.

2. **Baseline Request**:
   - Accesses `/index/?sort_by=priority` to get the normal task order (sorted by priority).

3. **Injected Request**:
   - Uses `sort_by=(CASE WHEN (1=1) THEN title ELSE priority END)` to attempt to alter the sort logic via SQL injection.

4. **Assertions**:
   - **Baseline**: Ensures tasks are ordered by priority (titles 'B', 'A').
   - **Injected**: Checks if the order changes to alphabetical by title (titles 'A', 'B'), indicating successful SQL injection.

**Key Points**:
- **Direct Parameter Usage**: The `sort_by` parameter is used unsanitized in `order_by()`, allowing SQL control.
- **Outcome Verification**: The test confirms vulnerability by detecting an unexpected task order change via HTML parsing.

This test validates the presence of SQL injection by observing whether raw SQL in `sort_by` alters query behavior.

Process finished with exit code 0
