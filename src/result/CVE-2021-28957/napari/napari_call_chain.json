[
    [
        {
            "function_name": "test_nbscreenshot",
            "file_path": "PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2021-28957/napari/napari/_tests/test_notebook_display.py",
            "line_number": 12,
            "source_code": "def test_nbscreenshot(make_napari_viewer):\n    \"\"\"Test taking a screenshot.\"\"\"\n    viewer = make_napari_viewer()\n\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    viewer.add_image(data)\n\n    rich_display_object = nbscreenshot(viewer)\n    assert hasattr(rich_display_object, '_repr_png_')\n    # Trigger method that would run in jupyter notebook cell automatically\n    rich_display_object._repr_png_()\n    assert rich_display_object.image is not None\n",
            "parameters": [],
            "focused_calls": [
                "clean_html"
            ],
            "extend_calls": [
                "def _repr_png_(self):\n        \"\"\"PNG representation of the viewer object for IPython.\n\n        Returns\n        -------\n        In memory binary stream containing PNG screenshot image.\n        \"\"\"\n        from imageio import imsave\n\n        from napari._qt.qt_event_loop import get_app\n\n        get_app().processEvents()\n        self.image = self.viewer.screenshot(\n            canvas_only=self.canvas_only, flash=False\n        )\n        with BytesIO() as file_obj:\n            imsave(file_obj, self.image, format='png')\n            file_obj.seek(0)\n            png = file_obj.read()\n        return png",
                "def make_napari_viewer(\n    qtbot,\n    request: 'FixtureRequest',\n    napari_plugin_manager,\n    monkeypatch,\n    clean_themes,\n):\n    \"\"\"A fixture function that creates a napari viewer for use in testing.\n\n    Use this fixture as a function in your tests:\n\n        viewer = make_napari_viewer()\n\n    It accepts all the same arguments as napari.Viewer, plus the following\n    test-related paramaters:\n\n    ViewerClass : Type[napari.Viewer], optional\n        Override the viewer class being used.  By default, will\n        use napari.viewer.Viewer\n    strict_qt : bool or str, optional\n        If True, a check will be performed after test cleanup to make sure that\n        no top level widgets were created and *not* cleaned up during the\n        test.  If the string \"raise\" is provided, an AssertionError will be\n        raised.  Otherwise a warning is emitted.\n        By default, this is False unless the test is being performed within\n        the napari package.\n        This can be made globally true by setting the 'NAPARI_STRICT_QT'\n        environment variable.\n    block_plugin_discovery : bool, optional\n        Block discovery of non-builtin plugins.  Note: plugins can still be\n        manually registered by using the 'napari_plugin_manager' fixture and\n        the `napari_plugin_manager.register()` method. By default, True.\n\n    Examples\n    --------\n    >>> def test_adding_shapes(make_napari_viewer):\n    ...     viewer = make_napari_viewer()\n    ...     viewer.add_shapes()\n    ...     assert len(viewer.layers) == 1\n\n    >>> def test_something_with_plugins(make_napari_viewer):\n    ...     viewer = make_napari_viewer(block_plugin_discovery=False)\n\n    >>> def test_something_with_strict_qt_tests(make_napari_viewer):\n    ...     viewer = make_napari_viewer(strict_qt=True)\n    \"\"\"\n    from qtpy.QtWidgets import QApplication\n\n    from napari import Viewer\n    from napari._qt.qt_viewer import QtViewer\n    from napari.settings import get_settings\n\n    global GCPASS\n    GCPASS += 1\n\n    if GCPASS % 50 == 0:\n        gc.collect()\n    else:\n        gc.collect(1)\n\n    _do_not_inline_below = len(QtViewer._instances)\n    # # do not inline to avoid pytest trying to compute repr of expression.\n    # # it fails if C++ object gone but not Python object.\n    if request.config.getoption(_SAVE_GRAPH_OPNAME):\n        fail_obj_graph(QtViewer)\n    QtViewer._instances.clear()\n    assert _do_not_inline_below == 0, (\n        \"Some instance of QtViewer is not properly cleaned in one of previous test. For easier debug one may \"\n        f\"use {_SAVE_GRAPH_OPNAME} flag for pytest to get graph of leaked objects. If you use qtbot (from pytest-qt)\"\n        \" to clean Qt objects after test you may need to switch to manual clean using \"\n        \"`deleteLater()` and `qtbot.wait(50)` later.\"\n    )\n\n    settings = get_settings()\n    settings.reset()\n\n    viewers: WeakSet[Viewer] = WeakSet()\n\n    # may be overridden by using `make_napari_viewer(strict=True)`\n    _strict = False\n\n    initial = QApplication.topLevelWidgets()\n    prior_exception = getattr(sys, 'last_value', None)\n    is_internal_test = request.module.__name__.startswith(\"napari.\")\n\n    # disable throttling cursor event in tests\n    monkeypatch.setattr(\n        \"napari._qt.qt_main_window._QtMainWindow._throttle_cursor_to_status_connection\",\n        _empty,\n    )\n\n    def actual_factory(\n        *model_args,\n        ViewerClass=Viewer,\n        strict_qt=is_internal_test or os.getenv(\"NAPARI_STRICT_QT\"),\n        block_plugin_discovery=True,\n        **model_kwargs,\n    ):\n        nonlocal _strict\n        _strict = strict_qt\n\n        if not block_plugin_discovery:\n            napari_plugin_manager.discovery_blocker.stop()\n\n        should_show = request.config.getoption(\"--show-napari-viewer\")\n        model_kwargs['show'] = model_kwargs.pop('show', should_show)\n        viewer = ViewerClass(*model_args, **model_kwargs)\n        viewers.add(viewer)\n\n        return viewer\n\n    yield actual_factory\n\n    # Some tests might have the viewer closed, so this call will not be able\n    # to access the window.\n    with suppress(AttributeError):\n        get_settings().reset()\n\n    # close viewers, but don't saving window settings while closing\n    for viewer in viewers:\n        if hasattr(viewer.window, '_qt_window'):\n            with patch.object(\n                viewer.window._qt_window, '_save_current_window_settings'\n            ):\n                viewer.close()\n        else:\n            viewer.close()\n\n    if GCPASS % 50 == 0 or len(QtViewer._instances):\n        gc.collect()\n    else:\n        gc.collect(1)\n\n    if request.config.getoption(_SAVE_GRAPH_OPNAME):\n        fail_obj_graph(QtViewer)\n\n    if request.node.rep_call.failed:\n        # IF test failed do not check for leaks\n        QtViewer._instances.clear()\n\n    _do_not_inline_below = len(QtViewer._instances)\n\n    QtViewer._instances.clear()  # clear to prevent fail of next test\n\n    # do not inline to avoid pytest trying to compute repr of expression.\n    # it fails if C++ object gone but not Python object.\n    assert _do_not_inline_below == 0\n\n    # only check for leaked widgets if an exception was raised during the test,\n    # or \"strict\" mode was used.\n    if _strict and getattr(sys, 'last_value', None) is prior_exception:\n        QApplication.processEvents()\n        leak = set(QApplication.topLevelWidgets()).difference(initial)\n        # still not sure how to clean up some of the remaining vispy\n        # vispy.app.backends._qt.CanvasBackendDesktop widgets...\n        if any(n.__class__.__name__ != 'CanvasBackendDesktop' for n in leak):\n            # just a warning... but this can be converted to test errors\n            # in pytest with `-W error`\n            msg = f\"\"\"The following Widgets leaked!: {leak}.\n\n            Note: If other tests are failing it is likely that widgets will leak\n            as they will be (indirectly) attached to the tracebacks of previous failures.\n            Please only consider this an error if all other tests are passing.\n            \"\"\"\n            # Explanation notes on the above: While we are indeed looking at the\n            # difference in sets of widgets between before and after, new object can\n            # still not be garbage collected because of it.\n            # in particular with VisPyCanvas, it looks like if a traceback keeps\n            # contains the type, then instances are still attached to the type.\n            # I'm not too sure why this is the case though.\n            if _strict:\n                raise AssertionError(msg)\n            else:\n                warnings.warn(msg)",
                "def seed(self, seed):\n        self._seed = seed\n        # invalidate _all_vals to trigger re-generation\n        # in _raw_to_displayed\n        self._all_vals = np.array([])\n        self._selected_color = self.get_color(self.selected_label)\n        self.refresh()\n        self.events.selected_label()",
                "def add_image(\n        self,\n        data=None,\n        *,\n        channel_axis=None,\n        rgb=None,\n        colormap=None,\n        contrast_limits=None,\n        gamma=1,\n        interpolation2d='nearest',\n        interpolation3d='linear',\n        rendering='mip',\n        depiction='volume',\n        iso_threshold=None,\n        attenuation=0.05,\n        name=None,\n        metadata=None,\n        scale=None,\n        translate=None,\n        rotate=None,\n        shear=None,\n        affine=None,\n        opacity=1,\n        blending=None,\n        visible=True,\n        multiscale=None,\n        cache=True,\n        plane=None,\n        experimental_clipping_planes=None,\n    ) -> Union[Image, List[Image]]:\n        \"\"\"Add an image layer to the layer list.\n\n        Parameters\n        ----------\n        data : array or list of array\n            Image data. Can be N >= 2 dimensional. If the last dimension has length\n            3 or 4 can be interpreted as RGB or RGBA if rgb is `True`. If a\n            list and arrays are decreasing in shape then the data is treated as\n            a multiscale image. Please note multiscale rendering is only\n            supported in 2D. In 3D, only the lowest resolution scale is\n            displayed.\n        channel_axis : int, optional\n            Axis to expand image along.  If provided, each channel in the data\n            will be added as an individual image layer.  In channel_axis mode,\n            all other parameters MAY be provided as lists, and the Nth value\n            will be applied to the Nth channel in the data.  If a single value\n            is provided, it will be broadcast to all Layers.\n        rgb : bool or list\n            Whether the image is rgb RGB or RGBA. If not specified by user and\n            the last dimension of the data has length 3 or 4 it will be set as\n            `True`. If `False` the image is interpreted as a luminance image.\n            If a list then must be same length as the axis that is being\n            expanded as channels.\n        colormap : str, napari.utils.Colormap, tuple, dict, list\n            Colormaps to use for luminance images. If a string must be the name\n            of a supported colormap from vispy or matplotlib. If a tuple the\n            first value must be a string to assign as a name to a colormap and\n            the second item must be a Colormap. If a dict the key must be a\n            string to assign as a name to a colormap and the value must be a\n            Colormap. If a list then must be same length as the axis that is\n            being expanded as channels, and each colormap is applied to each\n            new image layer.\n        contrast_limits : list (2,)\n            Color limits to be used for determining the colormap bounds for\n            luminance images. If not passed is calculated as the min and max of\n            the image. If list of lists then must be same length as the axis\n            that is being expanded and then each colormap is applied to each\n            image.\n        gamma : list, float\n            Gamma correction for determining colormap linearity. Defaults to 1.\n            If a list then must be same length as the axis that is being\n            expanded as channels.\n        interpolation : str or list\n            Deprecated, to be removed in 0.6.0\n        interpolation2d : str or list\n            Interpolation mode used by vispy in 2D. Must be one of our supported\n            modes. If a list then must be same length as the axis that is being\n            expanded as channels.\n        interpolation3d : str or list\n            Interpolation mode used by vispy in 3D. Must be one of our supported\n            modes. If a list then must be same length as the axis that is being\n            expanded as channels.\n        rendering : str or list\n            Rendering mode used by vispy. Must be one of our supported\n            modes. If a list then must be same length as the axis that is being\n            expanded as channels.\n        depiction : str\n            Selects a preset volume depiction mode in vispy\n\n            * volume: images are rendered as 3D volumes.\n            * plane: images are rendered as 2D planes embedded in 3D.\n        iso_threshold : float or list\n            Threshold for isosurface. If a list then must be same length as the\n            axis that is being expanded as channels.\n        attenuation : float or list\n            Attenuation rate for attenuated maximum intensity projection. If a\n            list then must be same length as the axis that is being expanded as\n            channels.\n        name : str or list of str\n            Name of the layer.  If a list then must be same length as the axis\n            that is being expanded as channels.\n        metadata : dict or list of dict\n            Layer metadata. If a list then must be a list of dicts with the\n            same length as the axis that is being expanded as channels.\n        scale : tuple of float or list\n            Scale factors for the layer. If a list then must be a list of\n            tuples of float with the same length as the axis that is being\n            expanded as channels.\n        translate : tuple of float or list\n            Translation values for the layer. If a list then must be a list of\n            tuples of float with the same length as the axis that is being\n            expanded as channels.\n        rotate : float, 3-tuple of float, n-D array or list.\n            If a float convert into a 2D rotation matrix using that value as an\n            angle. If 3-tuple convert into a 3D rotation matrix, using a yaw,\n            pitch, roll convention. Otherwise assume an nD rotation. Angles are\n            assumed to be in degrees. They can be converted from radians with\n            np.degrees if needed. If a list then must have same length as\n            the axis that is being expanded as channels.\n        shear : 1-D array or list.\n            A vector of shear values for an upper triangular n-D shear matrix.\n            If a list then must have same length as the axis that is being\n            expanded as channels.\n        affine : n-D array or napari.utils.transforms.Affine\n            (N+1, N+1) affine transformation matrix in homogeneous coordinates.\n            The first (N, N) entries correspond to a linear transform and\n            the final column is a length N translation vector and a 1 or a\n            napari `Affine` transform object. Applied as an extra transform on\n            top of the provided scale, rotate, and shear values.\n        opacity : float or list\n            Opacity of the layer visual, between 0.0 and 1.0.  If a list then\n            must be same length as the axis that is being expanded as channels.\n        blending : str or list\n            One of a list of preset blending modes that determines how RGB and\n            alpha values of the layer visual get mixed. Allowed values are\n            {'opaque', 'translucent', and 'additive'}. If a list then\n            must be same length as the axis that is being expanded as channels.\n        visible : bool or list of bool\n            Whether the layer visual is currently being displayed.\n            If a list then must be same length as the axis that is\n            being expanded as channels.\n        multiscale : bool\n            Whether the data is a multiscale image or not. Multiscale data is\n            represented by a list of array like image data. If not specified by\n            the user and if the data is a list of arrays that decrease in shape\n            then it will be taken to be multiscale. The first image in the list\n            should be the largest. Please note multiscale rendering is only\n            supported in 2D. In 3D, only the lowest resolution scale is\n            displayed.\n        cache : bool\n            Whether slices of out-of-core datasets should be cached upon\n            retrieval. Currently, this only applies to dask arrays.\n        plane : dict or SlicingPlane\n            Properties defining plane rendering in 3D. Properties are defined in\n            data coordinates. Valid dictionary keys are\n            {'position', 'normal', 'thickness', and 'enabled'}.\n        experimental_clipping_planes : list of dicts, list of ClippingPlane, or ClippingPlaneList\n            Each dict defines a clipping plane in 3D in data coordinates.\n            Valid dictionary keys are {'position', 'normal', and 'enabled'}.\n            Values on the negative side of the normal are discarded if the plane is enabled.\n\n        Returns\n        -------\n        layer : :class:`napari.layers.Image` or list\n            The newly-created image layer or list of image layers.\n        \"\"\"\n\n        if colormap is not None:\n            # standardize colormap argument(s) to Colormaps, and make sure they\n            # are in AVAILABLE_COLORMAPS.  This will raise one of many various\n            # errors if the colormap argument is invalid.  See\n            # ensure_colormap for details\n            if isinstance(colormap, list):\n                colormap = [ensure_colormap(c) for c in colormap]\n            else:\n                colormap = ensure_colormap(colormap)\n\n        # doing this here for IDE/console autocompletion in add_image function.\n        kwargs = {\n            'rgb': rgb,\n            'colormap': colormap,\n            'contrast_limits': contrast_limits,\n            'gamma': gamma,\n            'interpolation2d': interpolation2d,\n            'interpolation3d': interpolation3d,\n            'rendering': rendering,\n            'depiction': depiction,\n            'iso_threshold': iso_threshold,\n            'attenuation': attenuation,\n            'name': name,\n            'metadata': metadata,\n            'scale': scale,\n            'translate': translate,\n            'rotate': rotate,\n            'shear': shear,\n            'affine': affine,\n            'opacity': opacity,\n            'blending': blending,\n            'visible': visible,\n            'multiscale': multiscale,\n            'cache': cache,\n            'plane': plane,\n            'experimental_clipping_planes': experimental_clipping_planes,\n        }\n\n        # these arguments are *already* iterables in the single-channel case.\n        iterable_kwargs = {\n            'scale',\n            'translate',\n            'rotate',\n            'shear',\n            'affine',\n            'contrast_limits',\n            'metadata',\n            'experimental_clipping_planes',\n        }\n\n        if channel_axis is None:\n            kwargs['colormap'] = kwargs['colormap'] or 'gray'\n            kwargs['blending'] = kwargs['blending'] or 'translucent_no_depth'\n            # Helpful message if someone tries to add multi-channel kwargs,\n            # but forget the channel_axis arg\n            for k, v in kwargs.items():\n                if k not in iterable_kwargs and is_sequence(v):\n                    raise TypeError(\n                        trans._(\n                            \"Received sequence for argument '{argument}', did you mean to specify a 'channel_axis'? \",\n                            deferred=True,\n                            argument=k,\n                        )\n                    )\n            layer = Image(data, **kwargs)\n            self.layers.append(layer)\n\n            return layer\n        else:\n            layerdata_list = split_channels(data, channel_axis, **kwargs)\n\n            layer_list = list()\n            for image, i_kwargs, _ in layerdata_list:\n                layer = Image(image, **i_kwargs)\n                self.layers.append(layer)\n                layer_list.append(layer)\n\n            return layer_list"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2021-28957/napari/napari/_tests/test_notebook_display.py:test_nbscreenshot:12"
        }
    ],
    [
        {
            "function_name": "test_safe_alt_text",
            "file_path": "PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2021-28957/napari/napari/_tests/test_notebook_display.py",
            "line_number": 54,
            "source_code": "def test_safe_alt_text(alt_text_input, expected_alt_text):\n    display_obj = nbscreenshot(Mock(), alt_text=alt_text_input)\n    if not expected_alt_text:\n        assert not display_obj.alt_text\n    else:\n        assert html.escape(display_obj.alt_text) == expected_alt_text\n",
            "parameters": [],
            "focused_calls": [
                "clean_html"
            ],
            "extend_calls": [],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2021-28957/napari/napari/_tests/test_notebook_display.py:test_safe_alt_text:54"
        }
    ]
]
