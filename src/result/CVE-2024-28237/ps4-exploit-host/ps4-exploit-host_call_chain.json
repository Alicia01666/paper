[
    [
        {
            "function_name": "my_sender",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 70,
            "source_code": "    def my_sender(self, mime, content):\n        \"\"\"Here to prevent code duplication\"\"\"\n        try:\n            self.send_response(200)\n            self.send_header('Content-Type', mime)\n            self.send_header('Content-Length', len(content))\n            self.send_header('Connection', 'close')\n            self.end_headers()\n            self.wfile.write(content)\n        except socket.error:\n            print('ERROR: Broken Pipe (Out of Memory?)')\n",
            "parameters": [],
            "focused_calls": [
                "send_header"
            ],
            "extend_calls": [
                "def send_response(self, code, message=None):\n        \"\"\"Blanks out default headers\"\"\"\n        self.log_request(code)\n        self.send_response_only(code, message)"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:my_sender:70"
        },
        {
            "function_name": "updatelist",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 82,
            "source_code": "    def updatelist(self):\n        region = self.path.split('/')[4]\n        path = os.path.join(UPDATE_LOC, 'ps4-updatelist.xml')\n        with open(path, 'rb') as buf:\n            xml = buf.read()\n        xml = xml.replace(b'{{REGION}}', bytes(region, 'utf-8'))\n        self.my_sender('application/xml', xml)\n",
            "parameters": [],
            "focused_calls": [
                "my_sender"
            ],
            "extend_calls": [
                "def my_sender(self, mime, content):\n        \"\"\"Here to prevent code duplication\"\"\"\n        try:\n            self.send_response(200)\n            self.send_header('Content-Type', mime)\n            self.send_header('Content-Length', len(content))\n            self.send_header('Connection', 'close')\n            self.end_headers()\n            self.wfile.write(content)\n        except socket.error:\n            print('ERROR: Broken Pipe (Out of Memory?)')"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:updatelist:82"
        },
        {
            "function_name": "do_GET",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 187,
            "source_code": "    def do_GET(self):\n        \"\"\"Determines how to handle HTTP requests\"\"\"\n        try:\n            if re.match(r'^\\/update\\/ps4\\/list\\/[a-z]{2}\\/ps4\\-updatelist\\.xml', self.path):\n                self.updatelist()\n            elif re.match(r'^\\/update\\/ps4\\/html\\/[a-z]{2}\\/[a-z]{2}\\/ps4\\-updatefeature\\.html', self.path):\n                self.updatefeature()\n            elif re.match(r'^\\/update\\/ps4\\/image\\/[0-9]{4}_[0-9]{4}\\/(sys|rec)\\_[a-f0-9]{32}\\/PS4UPDATE\\.PUP', self.path):\n                self.update_pup()\n            elif re.match(r'^\\/networktest\\/get\\_2m', self.path):\n                self.network_test(2097152)\n            elif re.match(r'^\\/networktest\\/get\\_6m', self.path):\n                self.network_test(6291456)\n            elif re.match(r'^\\/$', self.path) or re.match(r'^\\/index\\.html', self.path) or re.match(r'^\\/document\\/[a-zA-Z\\-]{2,5}\\/ps4\\/index\\.html', self.path) or re.match(r'^\\/document\\/[a-zA-Z\\-]{2,5}\\/ps4\\/', self.path):\n                if self.check_ua():\n                    self.exploit_matcher()\n                else:\n                    self.send_error(400, explain='This PS4 is not on the right firmware (4.05)')\n                    print('>> Non-4.05 PS4 attempted to access exploits')\n            elif re.match(r'^\\/exploits\\/.*\\/', self.path):\n                if self.check_ua():\n                    self.exploit()\n                else:\n                    self.send_error(400, explain='This PS4 is not on the right firmware (4.05)')\n                    print('>> Non-4.05 PS4 attempted to access exploits')\n            elif re.match(r'^\\/static\\/', self.path):\n                self.static_request()\n            else:\n                self.send_error(404)\n        except IOError:\n            self.send_error(404)\n\n        if self.path.rsplit('/', 1)[-1] == 'rop.js':\n            print('>> Exploit sent...')\n            try:\n                payloads_file = os.path.join(EXPLOIT_LOC, self.path.rsplit('/', 2)[-2], 'nopayloads')\n                if os.path.isfile(payloads_file):\n                    print('>> Exploit does not support payload, skipping payload menu')\n                else:\n                    self.payload_launcher()\n            except (IOError, PermissionError):\n                print('>> ERROR Could not determine if exploit accepts payloads')\n                print('>> Payload menu will be loaded anyway...')\n                time.sleep(3)\n                self.payload_launcher()\n",
            "parameters": [],
            "focused_calls": [
                "updatelist"
            ],
            "extend_calls": [
                "def static_request(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(STATIC_LOC, path), 'rb') as buf:\n            data = buf.read()\n        self.my_sender(mime, data)",
                "def updatelist(self):\n        region = self.path.split('/')[4]\n        path = os.path.join(UPDATE_LOC, 'ps4-updatelist.xml')\n        with open(path, 'rb') as buf:\n            xml = buf.read()\n        xml = xml.replace(b'{{REGION}}', bytes(region, 'utf-8'))\n        self.my_sender('application/xml', xml)",
                "def network_test(self, size):\n        data = b'\\0' * size\n        self.my_sender('text/plain', data)",
                "def updatefeature(self):\n        path = os.path.join(HTML_LOC, 'ps4-updatefeature.html')\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        data = self.inject_image_html(data)\n        self.my_sender('text/html', data)",
                "def exploit_matcher(self):\n        with open(os.path.join(HTML_LOC, 'exploits.html'), 'rb') as buf:\n            data = buf.read()\n        data = self.inject_exploit_html(data)\n        self.my_sender('text/html', data)",
                "def check_ua(self):\n        \"\"\"Have to allow 4.05 and 5.05 because the spoofer changes the UA\"\"\"\n        if self.headers['User-Agent'] == 'Mozilla/5.0 (PlayStation 4 4.05) AppleWebKit/537.78 (KHTML, like Gecko)' or \\\n           self.headers['User-Agent'] == 'Mozilla/5.0 (PlayStation 4 5.05) AppleWebKit/537.78 (KHTML, like Gecko)':\n            return True\n        else:\n            return False",
                "def payload_launcher(self):\n        payload_menu = True\n        for thread in threading.enumerate():\n            if thread.name == 'Payload_Brain':\n                payload_menu = False\n\n        if payload_menu:\n            thread = threading.Thread(name='Payload_Brain',\n                                      target=payload_brain,\n                                      args=(self.client_address[0],),\n                                      daemon=True)\n            thread.start()",
                "def exploit(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        if not path or path == '/':\n            path = 'index.html'\n        which = unquote(self.path.rsplit('/')[-2])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(EXPLOIT_LOC, which, path), 'rb') as buf:\n            data = buf.read()\n        if path == 'index.html':\n            data = data.replace(b'0.0.0.0', bytes(get_lan(), 'utf-8'))\n        self.my_sender(mime, data)",
                "def update_pup(self):\n        if 'sys' in self.path:\n            check_update_pup('SYSTEM', '203C76C97F7BE5B881DD0C77C8EDF385')\n            path = 'PS4UPDATE_SYSTEM.PUP'\n        elif 'rec' in self.path:\n            check_update_pup('RECOVERY', '741CFE2F0DEC1BB4663571DE78AE31CF')\n            path = 'PS4UPDATE_RECOVERY.PUP'\n        else:\n            path = ''\n        path = os.path.join(UPDATE_LOC, path)\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        self.my_sender('text/plain', data)"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:do_GET:187"
        }
    ],
    [
        {
            "function_name": "my_sender",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 70,
            "source_code": "    def my_sender(self, mime, content):\n        \"\"\"Here to prevent code duplication\"\"\"\n        try:\n            self.send_response(200)\n            self.send_header('Content-Type', mime)\n            self.send_header('Content-Length', len(content))\n            self.send_header('Connection', 'close')\n            self.end_headers()\n            self.wfile.write(content)\n        except socket.error:\n            print('ERROR: Broken Pipe (Out of Memory?)')\n",
            "parameters": [],
            "focused_calls": [
                "send_header"
            ],
            "extend_calls": [
                "def send_response(self, code, message=None):\n        \"\"\"Blanks out default headers\"\"\"\n        self.log_request(code)\n        self.send_response_only(code, message)"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:my_sender:70"
        },
        {
            "function_name": "updatefeature",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 90,
            "source_code": "    def updatefeature(self):\n        path = os.path.join(HTML_LOC, 'ps4-updatefeature.html')\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        data = self.inject_image_html(data)\n        self.my_sender('text/html', data)\n",
            "parameters": [],
            "focused_calls": [
                "my_sender"
            ],
            "extend_calls": [
                "def my_sender(self, mime, content):\n        \"\"\"Here to prevent code duplication\"\"\"\n        try:\n            self.send_response(200)\n            self.send_header('Content-Type', mime)\n            self.send_header('Content-Length', len(content))\n            self.send_header('Connection', 'close')\n            self.end_headers()\n            self.wfile.write(content)\n        except socket.error:\n            print('ERROR: Broken Pipe (Out of Memory?)')"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:updatefeature:90"
        },
        {
            "function_name": "do_GET",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 187,
            "source_code": "    def do_GET(self):\n        \"\"\"Determines how to handle HTTP requests\"\"\"\n        try:\n            if re.match(r'^\\/update\\/ps4\\/list\\/[a-z]{2}\\/ps4\\-updatelist\\.xml', self.path):\n                self.updatelist()\n            elif re.match(r'^\\/update\\/ps4\\/html\\/[a-z]{2}\\/[a-z]{2}\\/ps4\\-updatefeature\\.html', self.path):\n                self.updatefeature()\n            elif re.match(r'^\\/update\\/ps4\\/image\\/[0-9]{4}_[0-9]{4}\\/(sys|rec)\\_[a-f0-9]{32}\\/PS4UPDATE\\.PUP', self.path):\n                self.update_pup()\n            elif re.match(r'^\\/networktest\\/get\\_2m', self.path):\n                self.network_test(2097152)\n            elif re.match(r'^\\/networktest\\/get\\_6m', self.path):\n                self.network_test(6291456)\n            elif re.match(r'^\\/$', self.path) or re.match(r'^\\/index\\.html', self.path) or re.match(r'^\\/document\\/[a-zA-Z\\-]{2,5}\\/ps4\\/index\\.html', self.path) or re.match(r'^\\/document\\/[a-zA-Z\\-]{2,5}\\/ps4\\/', self.path):\n                if self.check_ua():\n                    self.exploit_matcher()\n                else:\n                    self.send_error(400, explain='This PS4 is not on the right firmware (4.05)')\n                    print('>> Non-4.05 PS4 attempted to access exploits')\n            elif re.match(r'^\\/exploits\\/.*\\/', self.path):\n                if self.check_ua():\n                    self.exploit()\n                else:\n                    self.send_error(400, explain='This PS4 is not on the right firmware (4.05)')\n                    print('>> Non-4.05 PS4 attempted to access exploits')\n            elif re.match(r'^\\/static\\/', self.path):\n                self.static_request()\n            else:\n                self.send_error(404)\n        except IOError:\n            self.send_error(404)\n\n        if self.path.rsplit('/', 1)[-1] == 'rop.js':\n            print('>> Exploit sent...')\n            try:\n                payloads_file = os.path.join(EXPLOIT_LOC, self.path.rsplit('/', 2)[-2], 'nopayloads')\n                if os.path.isfile(payloads_file):\n                    print('>> Exploit does not support payload, skipping payload menu')\n                else:\n                    self.payload_launcher()\n            except (IOError, PermissionError):\n                print('>> ERROR Could not determine if exploit accepts payloads')\n                print('>> Payload menu will be loaded anyway...')\n                time.sleep(3)\n                self.payload_launcher()\n",
            "parameters": [],
            "focused_calls": [
                "updatefeature"
            ],
            "extend_calls": [
                "def static_request(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(STATIC_LOC, path), 'rb') as buf:\n            data = buf.read()\n        self.my_sender(mime, data)",
                "def updatelist(self):\n        region = self.path.split('/')[4]\n        path = os.path.join(UPDATE_LOC, 'ps4-updatelist.xml')\n        with open(path, 'rb') as buf:\n            xml = buf.read()\n        xml = xml.replace(b'{{REGION}}', bytes(region, 'utf-8'))\n        self.my_sender('application/xml', xml)",
                "def network_test(self, size):\n        data = b'\\0' * size\n        self.my_sender('text/plain', data)",
                "def updatefeature(self):\n        path = os.path.join(HTML_LOC, 'ps4-updatefeature.html')\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        data = self.inject_image_html(data)\n        self.my_sender('text/html', data)",
                "def exploit_matcher(self):\n        with open(os.path.join(HTML_LOC, 'exploits.html'), 'rb') as buf:\n            data = buf.read()\n        data = self.inject_exploit_html(data)\n        self.my_sender('text/html', data)",
                "def check_ua(self):\n        \"\"\"Have to allow 4.05 and 5.05 because the spoofer changes the UA\"\"\"\n        if self.headers['User-Agent'] == 'Mozilla/5.0 (PlayStation 4 4.05) AppleWebKit/537.78 (KHTML, like Gecko)' or \\\n           self.headers['User-Agent'] == 'Mozilla/5.0 (PlayStation 4 5.05) AppleWebKit/537.78 (KHTML, like Gecko)':\n            return True\n        else:\n            return False",
                "def payload_launcher(self):\n        payload_menu = True\n        for thread in threading.enumerate():\n            if thread.name == 'Payload_Brain':\n                payload_menu = False\n\n        if payload_menu:\n            thread = threading.Thread(name='Payload_Brain',\n                                      target=payload_brain,\n                                      args=(self.client_address[0],),\n                                      daemon=True)\n            thread.start()",
                "def exploit(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        if not path or path == '/':\n            path = 'index.html'\n        which = unquote(self.path.rsplit('/')[-2])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(EXPLOIT_LOC, which, path), 'rb') as buf:\n            data = buf.read()\n        if path == 'index.html':\n            data = data.replace(b'0.0.0.0', bytes(get_lan(), 'utf-8'))\n        self.my_sender(mime, data)",
                "def update_pup(self):\n        if 'sys' in self.path:\n            check_update_pup('SYSTEM', '203C76C97F7BE5B881DD0C77C8EDF385')\n            path = 'PS4UPDATE_SYSTEM.PUP'\n        elif 'rec' in self.path:\n            check_update_pup('RECOVERY', '741CFE2F0DEC1BB4663571DE78AE31CF')\n            path = 'PS4UPDATE_RECOVERY.PUP'\n        else:\n            path = ''\n        path = os.path.join(UPDATE_LOC, path)\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        self.my_sender('text/plain', data)"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:do_GET:187"
        }
    ],
    [
        {
            "function_name": "my_sender",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 70,
            "source_code": "    def my_sender(self, mime, content):\n        \"\"\"Here to prevent code duplication\"\"\"\n        try:\n            self.send_response(200)\n            self.send_header('Content-Type', mime)\n            self.send_header('Content-Length', len(content))\n            self.send_header('Connection', 'close')\n            self.end_headers()\n            self.wfile.write(content)\n        except socket.error:\n            print('ERROR: Broken Pipe (Out of Memory?)')\n",
            "parameters": [],
            "focused_calls": [
                "send_header"
            ],
            "extend_calls": [
                "def send_response(self, code, message=None):\n        \"\"\"Blanks out default headers\"\"\"\n        self.log_request(code)\n        self.send_response_only(code, message)"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:my_sender:70"
        },
        {
            "function_name": "update_pup",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 97,
            "source_code": "    def update_pup(self):\n        if 'sys' in self.path:\n            check_update_pup('SYSTEM', '203C76C97F7BE5B881DD0C77C8EDF385')\n            path = 'PS4UPDATE_SYSTEM.PUP'\n        elif 'rec' in self.path:\n            check_update_pup('RECOVERY', '741CFE2F0DEC1BB4663571DE78AE31CF')\n            path = 'PS4UPDATE_RECOVERY.PUP'\n        else:\n            path = ''\n        path = os.path.join(UPDATE_LOC, path)\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        self.my_sender('text/plain', data)\n",
            "parameters": [],
            "focused_calls": [
                "my_sender"
            ],
            "extend_calls": [
                "def check_update_pup(type, md5):\n    try:\n        update_name = 'PS4UPDATE_{}.PUP'.format(type)\n        with open(os.path.join(UPDATE_LOC, update_name), 'rb') as buf:\n            data = buf.read()\n        check = '>> Checking {}\\'s checksum'.format(update_name)\n        print(check, end='\\r')\n        hasher = hashlib.md5()\n        hasher.update(data)\n        system_hash = hasher.hexdigest().upper()\n        if system_hash != md5:\n            closer('ERROR: {} is not version 4.05'.format(update_name))\n        print('>> {} checksum matches   '.format(update_name))\n    except IOError:\n        pass",
                "def my_sender(self, mime, content):\n        \"\"\"Here to prevent code duplication\"\"\"\n        try:\n            self.send_response(200)\n            self.send_header('Content-Type', mime)\n            self.send_header('Content-Length', len(content))\n            self.send_header('Connection', 'close')\n            self.end_headers()\n            self.wfile.write(content)\n        except socket.error:\n            print('ERROR: Broken Pipe (Out of Memory?)')"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:update_pup:97"
        },
        {
            "function_name": "do_GET",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 187,
            "source_code": "    def do_GET(self):\n        \"\"\"Determines how to handle HTTP requests\"\"\"\n        try:\n            if re.match(r'^\\/update\\/ps4\\/list\\/[a-z]{2}\\/ps4\\-updatelist\\.xml', self.path):\n                self.updatelist()\n            elif re.match(r'^\\/update\\/ps4\\/html\\/[a-z]{2}\\/[a-z]{2}\\/ps4\\-updatefeature\\.html', self.path):\n                self.updatefeature()\n            elif re.match(r'^\\/update\\/ps4\\/image\\/[0-9]{4}_[0-9]{4}\\/(sys|rec)\\_[a-f0-9]{32}\\/PS4UPDATE\\.PUP', self.path):\n                self.update_pup()\n            elif re.match(r'^\\/networktest\\/get\\_2m', self.path):\n                self.network_test(2097152)\n            elif re.match(r'^\\/networktest\\/get\\_6m', self.path):\n                self.network_test(6291456)\n            elif re.match(r'^\\/$', self.path) or re.match(r'^\\/index\\.html', self.path) or re.match(r'^\\/document\\/[a-zA-Z\\-]{2,5}\\/ps4\\/index\\.html', self.path) or re.match(r'^\\/document\\/[a-zA-Z\\-]{2,5}\\/ps4\\/', self.path):\n                if self.check_ua():\n                    self.exploit_matcher()\n                else:\n                    self.send_error(400, explain='This PS4 is not on the right firmware (4.05)')\n                    print('>> Non-4.05 PS4 attempted to access exploits')\n            elif re.match(r'^\\/exploits\\/.*\\/', self.path):\n                if self.check_ua():\n                    self.exploit()\n                else:\n                    self.send_error(400, explain='This PS4 is not on the right firmware (4.05)')\n                    print('>> Non-4.05 PS4 attempted to access exploits')\n            elif re.match(r'^\\/static\\/', self.path):\n                self.static_request()\n            else:\n                self.send_error(404)\n        except IOError:\n            self.send_error(404)\n\n        if self.path.rsplit('/', 1)[-1] == 'rop.js':\n            print('>> Exploit sent...')\n            try:\n                payloads_file = os.path.join(EXPLOIT_LOC, self.path.rsplit('/', 2)[-2], 'nopayloads')\n                if os.path.isfile(payloads_file):\n                    print('>> Exploit does not support payload, skipping payload menu')\n                else:\n                    self.payload_launcher()\n            except (IOError, PermissionError):\n                print('>> ERROR Could not determine if exploit accepts payloads')\n                print('>> Payload menu will be loaded anyway...')\n                time.sleep(3)\n                self.payload_launcher()\n",
            "parameters": [],
            "focused_calls": [
                "update_pup"
            ],
            "extend_calls": [
                "def static_request(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(STATIC_LOC, path), 'rb') as buf:\n            data = buf.read()\n        self.my_sender(mime, data)",
                "def updatelist(self):\n        region = self.path.split('/')[4]\n        path = os.path.join(UPDATE_LOC, 'ps4-updatelist.xml')\n        with open(path, 'rb') as buf:\n            xml = buf.read()\n        xml = xml.replace(b'{{REGION}}', bytes(region, 'utf-8'))\n        self.my_sender('application/xml', xml)",
                "def network_test(self, size):\n        data = b'\\0' * size\n        self.my_sender('text/plain', data)",
                "def updatefeature(self):\n        path = os.path.join(HTML_LOC, 'ps4-updatefeature.html')\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        data = self.inject_image_html(data)\n        self.my_sender('text/html', data)",
                "def exploit_matcher(self):\n        with open(os.path.join(HTML_LOC, 'exploits.html'), 'rb') as buf:\n            data = buf.read()\n        data = self.inject_exploit_html(data)\n        self.my_sender('text/html', data)",
                "def check_ua(self):\n        \"\"\"Have to allow 4.05 and 5.05 because the spoofer changes the UA\"\"\"\n        if self.headers['User-Agent'] == 'Mozilla/5.0 (PlayStation 4 4.05) AppleWebKit/537.78 (KHTML, like Gecko)' or \\\n           self.headers['User-Agent'] == 'Mozilla/5.0 (PlayStation 4 5.05) AppleWebKit/537.78 (KHTML, like Gecko)':\n            return True\n        else:\n            return False",
                "def payload_launcher(self):\n        payload_menu = True\n        for thread in threading.enumerate():\n            if thread.name == 'Payload_Brain':\n                payload_menu = False\n\n        if payload_menu:\n            thread = threading.Thread(name='Payload_Brain',\n                                      target=payload_brain,\n                                      args=(self.client_address[0],),\n                                      daemon=True)\n            thread.start()",
                "def exploit(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        if not path or path == '/':\n            path = 'index.html'\n        which = unquote(self.path.rsplit('/')[-2])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(EXPLOIT_LOC, which, path), 'rb') as buf:\n            data = buf.read()\n        if path == 'index.html':\n            data = data.replace(b'0.0.0.0', bytes(get_lan(), 'utf-8'))\n        self.my_sender(mime, data)",
                "def update_pup(self):\n        if 'sys' in self.path:\n            check_update_pup('SYSTEM', '203C76C97F7BE5B881DD0C77C8EDF385')\n            path = 'PS4UPDATE_SYSTEM.PUP'\n        elif 'rec' in self.path:\n            check_update_pup('RECOVERY', '741CFE2F0DEC1BB4663571DE78AE31CF')\n            path = 'PS4UPDATE_RECOVERY.PUP'\n        else:\n            path = ''\n        path = os.path.join(UPDATE_LOC, path)\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        self.my_sender('text/plain', data)"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:do_GET:187"
        }
    ],
    [
        {
            "function_name": "my_sender",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 70,
            "source_code": "    def my_sender(self, mime, content):\n        \"\"\"Here to prevent code duplication\"\"\"\n        try:\n            self.send_response(200)\n            self.send_header('Content-Type', mime)\n            self.send_header('Content-Length', len(content))\n            self.send_header('Connection', 'close')\n            self.end_headers()\n            self.wfile.write(content)\n        except socket.error:\n            print('ERROR: Broken Pipe (Out of Memory?)')\n",
            "parameters": [],
            "focused_calls": [
                "send_header"
            ],
            "extend_calls": [
                "def send_response(self, code, message=None):\n        \"\"\"Blanks out default headers\"\"\"\n        self.log_request(code)\n        self.send_response_only(code, message)"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:my_sender:70"
        },
        {
            "function_name": "network_test",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 111,
            "source_code": "    def network_test(self, size):\n        data = b'\\0' * size\n        self.my_sender('text/plain', data)\n",
            "parameters": [],
            "focused_calls": [
                "my_sender"
            ],
            "extend_calls": [
                "def my_sender(self, mime, content):\n        \"\"\"Here to prevent code duplication\"\"\"\n        try:\n            self.send_response(200)\n            self.send_header('Content-Type', mime)\n            self.send_header('Content-Length', len(content))\n            self.send_header('Connection', 'close')\n            self.end_headers()\n            self.wfile.write(content)\n        except socket.error:\n            print('ERROR: Broken Pipe (Out of Memory?)')"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:network_test:111"
        },
        {
            "function_name": "do_GET",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 187,
            "source_code": "    def do_GET(self):\n        \"\"\"Determines how to handle HTTP requests\"\"\"\n        try:\n            if re.match(r'^\\/update\\/ps4\\/list\\/[a-z]{2}\\/ps4\\-updatelist\\.xml', self.path):\n                self.updatelist()\n            elif re.match(r'^\\/update\\/ps4\\/html\\/[a-z]{2}\\/[a-z]{2}\\/ps4\\-updatefeature\\.html', self.path):\n                self.updatefeature()\n            elif re.match(r'^\\/update\\/ps4\\/image\\/[0-9]{4}_[0-9]{4}\\/(sys|rec)\\_[a-f0-9]{32}\\/PS4UPDATE\\.PUP', self.path):\n                self.update_pup()\n            elif re.match(r'^\\/networktest\\/get\\_2m', self.path):\n                self.network_test(2097152)\n            elif re.match(r'^\\/networktest\\/get\\_6m', self.path):\n                self.network_test(6291456)\n            elif re.match(r'^\\/$', self.path) or re.match(r'^\\/index\\.html', self.path) or re.match(r'^\\/document\\/[a-zA-Z\\-]{2,5}\\/ps4\\/index\\.html', self.path) or re.match(r'^\\/document\\/[a-zA-Z\\-]{2,5}\\/ps4\\/', self.path):\n                if self.check_ua():\n                    self.exploit_matcher()\n                else:\n                    self.send_error(400, explain='This PS4 is not on the right firmware (4.05)')\n                    print('>> Non-4.05 PS4 attempted to access exploits')\n            elif re.match(r'^\\/exploits\\/.*\\/', self.path):\n                if self.check_ua():\n                    self.exploit()\n                else:\n                    self.send_error(400, explain='This PS4 is not on the right firmware (4.05)')\n                    print('>> Non-4.05 PS4 attempted to access exploits')\n            elif re.match(r'^\\/static\\/', self.path):\n                self.static_request()\n            else:\n                self.send_error(404)\n        except IOError:\n            self.send_error(404)\n\n        if self.path.rsplit('/', 1)[-1] == 'rop.js':\n            print('>> Exploit sent...')\n            try:\n                payloads_file = os.path.join(EXPLOIT_LOC, self.path.rsplit('/', 2)[-2], 'nopayloads')\n                if os.path.isfile(payloads_file):\n                    print('>> Exploit does not support payload, skipping payload menu')\n                else:\n                    self.payload_launcher()\n            except (IOError, PermissionError):\n                print('>> ERROR Could not determine if exploit accepts payloads')\n                print('>> Payload menu will be loaded anyway...')\n                time.sleep(3)\n                self.payload_launcher()\n",
            "parameters": [],
            "focused_calls": [
                "network_test"
            ],
            "extend_calls": [
                "def static_request(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(STATIC_LOC, path), 'rb') as buf:\n            data = buf.read()\n        self.my_sender(mime, data)",
                "def updatelist(self):\n        region = self.path.split('/')[4]\n        path = os.path.join(UPDATE_LOC, 'ps4-updatelist.xml')\n        with open(path, 'rb') as buf:\n            xml = buf.read()\n        xml = xml.replace(b'{{REGION}}', bytes(region, 'utf-8'))\n        self.my_sender('application/xml', xml)",
                "def network_test(self, size):\n        data = b'\\0' * size\n        self.my_sender('text/plain', data)",
                "def updatefeature(self):\n        path = os.path.join(HTML_LOC, 'ps4-updatefeature.html')\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        data = self.inject_image_html(data)\n        self.my_sender('text/html', data)",
                "def exploit_matcher(self):\n        with open(os.path.join(HTML_LOC, 'exploits.html'), 'rb') as buf:\n            data = buf.read()\n        data = self.inject_exploit_html(data)\n        self.my_sender('text/html', data)",
                "def check_ua(self):\n        \"\"\"Have to allow 4.05 and 5.05 because the spoofer changes the UA\"\"\"\n        if self.headers['User-Agent'] == 'Mozilla/5.0 (PlayStation 4 4.05) AppleWebKit/537.78 (KHTML, like Gecko)' or \\\n           self.headers['User-Agent'] == 'Mozilla/5.0 (PlayStation 4 5.05) AppleWebKit/537.78 (KHTML, like Gecko)':\n            return True\n        else:\n            return False",
                "def payload_launcher(self):\n        payload_menu = True\n        for thread in threading.enumerate():\n            if thread.name == 'Payload_Brain':\n                payload_menu = False\n\n        if payload_menu:\n            thread = threading.Thread(name='Payload_Brain',\n                                      target=payload_brain,\n                                      args=(self.client_address[0],),\n                                      daemon=True)\n            thread.start()",
                "def exploit(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        if not path or path == '/':\n            path = 'index.html'\n        which = unquote(self.path.rsplit('/')[-2])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(EXPLOIT_LOC, which, path), 'rb') as buf:\n            data = buf.read()\n        if path == 'index.html':\n            data = data.replace(b'0.0.0.0', bytes(get_lan(), 'utf-8'))\n        self.my_sender(mime, data)",
                "def update_pup(self):\n        if 'sys' in self.path:\n            check_update_pup('SYSTEM', '203C76C97F7BE5B881DD0C77C8EDF385')\n            path = 'PS4UPDATE_SYSTEM.PUP'\n        elif 'rec' in self.path:\n            check_update_pup('RECOVERY', '741CFE2F0DEC1BB4663571DE78AE31CF')\n            path = 'PS4UPDATE_RECOVERY.PUP'\n        else:\n            path = ''\n        path = os.path.join(UPDATE_LOC, path)\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        self.my_sender('text/plain', data)"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:do_GET:187"
        }
    ],
    [
        {
            "function_name": "my_sender",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 70,
            "source_code": "    def my_sender(self, mime, content):\n        \"\"\"Here to prevent code duplication\"\"\"\n        try:\n            self.send_response(200)\n            self.send_header('Content-Type', mime)\n            self.send_header('Content-Length', len(content))\n            self.send_header('Connection', 'close')\n            self.end_headers()\n            self.wfile.write(content)\n        except socket.error:\n            print('ERROR: Broken Pipe (Out of Memory?)')\n",
            "parameters": [],
            "focused_calls": [
                "send_header"
            ],
            "extend_calls": [
                "def send_response(self, code, message=None):\n        \"\"\"Blanks out default headers\"\"\"\n        self.log_request(code)\n        self.send_response_only(code, message)"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:my_sender:70"
        },
        {
            "function_name": "exploit_matcher",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 115,
            "source_code": "    def exploit_matcher(self):\n        with open(os.path.join(HTML_LOC, 'exploits.html'), 'rb') as buf:\n            data = buf.read()\n        data = self.inject_exploit_html(data)\n        self.my_sender('text/html', data)\n",
            "parameters": [],
            "focused_calls": [
                "my_sender"
            ],
            "extend_calls": [
                "def inject_exploit_html(self, html):\n        try:\n            exploits = os.listdir(EXPLOIT_LOC)\n            if 'PUT EXPLOITS HERE' in exploits:\n                exploits.remove('PUT EXPLOITS HERE')\n            exploits.sort()\n            if len(exploits) == 0:\n                return html\n            elif len(exploits) == 1:\n                data = '\"{}\"'.format(exploits[0])\n            else:\n                data = '\"' + '\", \"'.join(exploits) + '\"'\n            data = bytes(data, 'utf-8')\n        except IOError:\n            pass\n\n        return html.replace(b'{{EXPLOITS}}', data)",
                "def my_sender(self, mime, content):\n        \"\"\"Here to prevent code duplication\"\"\"\n        try:\n            self.send_response(200)\n            self.send_header('Content-Type', mime)\n            self.send_header('Content-Length', len(content))\n            self.send_header('Connection', 'close')\n            self.end_headers()\n            self.wfile.write(content)\n        except socket.error:\n            print('ERROR: Broken Pipe (Out of Memory?)')"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:exploit_matcher:115"
        },
        {
            "function_name": "do_GET",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 187,
            "source_code": "    def do_GET(self):\n        \"\"\"Determines how to handle HTTP requests\"\"\"\n        try:\n            if re.match(r'^\\/update\\/ps4\\/list\\/[a-z]{2}\\/ps4\\-updatelist\\.xml', self.path):\n                self.updatelist()\n            elif re.match(r'^\\/update\\/ps4\\/html\\/[a-z]{2}\\/[a-z]{2}\\/ps4\\-updatefeature\\.html', self.path):\n                self.updatefeature()\n            elif re.match(r'^\\/update\\/ps4\\/image\\/[0-9]{4}_[0-9]{4}\\/(sys|rec)\\_[a-f0-9]{32}\\/PS4UPDATE\\.PUP', self.path):\n                self.update_pup()\n            elif re.match(r'^\\/networktest\\/get\\_2m', self.path):\n                self.network_test(2097152)\n            elif re.match(r'^\\/networktest\\/get\\_6m', self.path):\n                self.network_test(6291456)\n            elif re.match(r'^\\/$', self.path) or re.match(r'^\\/index\\.html', self.path) or re.match(r'^\\/document\\/[a-zA-Z\\-]{2,5}\\/ps4\\/index\\.html', self.path) or re.match(r'^\\/document\\/[a-zA-Z\\-]{2,5}\\/ps4\\/', self.path):\n                if self.check_ua():\n                    self.exploit_matcher()\n                else:\n                    self.send_error(400, explain='This PS4 is not on the right firmware (4.05)')\n                    print('>> Non-4.05 PS4 attempted to access exploits')\n            elif re.match(r'^\\/exploits\\/.*\\/', self.path):\n                if self.check_ua():\n                    self.exploit()\n                else:\n                    self.send_error(400, explain='This PS4 is not on the right firmware (4.05)')\n                    print('>> Non-4.05 PS4 attempted to access exploits')\n            elif re.match(r'^\\/static\\/', self.path):\n                self.static_request()\n            else:\n                self.send_error(404)\n        except IOError:\n            self.send_error(404)\n\n        if self.path.rsplit('/', 1)[-1] == 'rop.js':\n            print('>> Exploit sent...')\n            try:\n                payloads_file = os.path.join(EXPLOIT_LOC, self.path.rsplit('/', 2)[-2], 'nopayloads')\n                if os.path.isfile(payloads_file):\n                    print('>> Exploit does not support payload, skipping payload menu')\n                else:\n                    self.payload_launcher()\n            except (IOError, PermissionError):\n                print('>> ERROR Could not determine if exploit accepts payloads')\n                print('>> Payload menu will be loaded anyway...')\n                time.sleep(3)\n                self.payload_launcher()\n",
            "parameters": [],
            "focused_calls": [
                "exploit_matcher"
            ],
            "extend_calls": [
                "def static_request(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(STATIC_LOC, path), 'rb') as buf:\n            data = buf.read()\n        self.my_sender(mime, data)",
                "def updatelist(self):\n        region = self.path.split('/')[4]\n        path = os.path.join(UPDATE_LOC, 'ps4-updatelist.xml')\n        with open(path, 'rb') as buf:\n            xml = buf.read()\n        xml = xml.replace(b'{{REGION}}', bytes(region, 'utf-8'))\n        self.my_sender('application/xml', xml)",
                "def network_test(self, size):\n        data = b'\\0' * size\n        self.my_sender('text/plain', data)",
                "def updatefeature(self):\n        path = os.path.join(HTML_LOC, 'ps4-updatefeature.html')\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        data = self.inject_image_html(data)\n        self.my_sender('text/html', data)",
                "def exploit_matcher(self):\n        with open(os.path.join(HTML_LOC, 'exploits.html'), 'rb') as buf:\n            data = buf.read()\n        data = self.inject_exploit_html(data)\n        self.my_sender('text/html', data)",
                "def check_ua(self):\n        \"\"\"Have to allow 4.05 and 5.05 because the spoofer changes the UA\"\"\"\n        if self.headers['User-Agent'] == 'Mozilla/5.0 (PlayStation 4 4.05) AppleWebKit/537.78 (KHTML, like Gecko)' or \\\n           self.headers['User-Agent'] == 'Mozilla/5.0 (PlayStation 4 5.05) AppleWebKit/537.78 (KHTML, like Gecko)':\n            return True\n        else:\n            return False",
                "def payload_launcher(self):\n        payload_menu = True\n        for thread in threading.enumerate():\n            if thread.name == 'Payload_Brain':\n                payload_menu = False\n\n        if payload_menu:\n            thread = threading.Thread(name='Payload_Brain',\n                                      target=payload_brain,\n                                      args=(self.client_address[0],),\n                                      daemon=True)\n            thread.start()",
                "def exploit(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        if not path or path == '/':\n            path = 'index.html'\n        which = unquote(self.path.rsplit('/')[-2])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(EXPLOIT_LOC, which, path), 'rb') as buf:\n            data = buf.read()\n        if path == 'index.html':\n            data = data.replace(b'0.0.0.0', bytes(get_lan(), 'utf-8'))\n        self.my_sender(mime, data)",
                "def update_pup(self):\n        if 'sys' in self.path:\n            check_update_pup('SYSTEM', '203C76C97F7BE5B881DD0C77C8EDF385')\n            path = 'PS4UPDATE_SYSTEM.PUP'\n        elif 'rec' in self.path:\n            check_update_pup('RECOVERY', '741CFE2F0DEC1BB4663571DE78AE31CF')\n            path = 'PS4UPDATE_RECOVERY.PUP'\n        else:\n            path = ''\n        path = os.path.join(UPDATE_LOC, path)\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        self.my_sender('text/plain', data)"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:do_GET:187"
        }
    ],
    [
        {
            "function_name": "my_sender",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 70,
            "source_code": "    def my_sender(self, mime, content):\n        \"\"\"Here to prevent code duplication\"\"\"\n        try:\n            self.send_response(200)\n            self.send_header('Content-Type', mime)\n            self.send_header('Content-Length', len(content))\n            self.send_header('Connection', 'close')\n            self.end_headers()\n            self.wfile.write(content)\n        except socket.error:\n            print('ERROR: Broken Pipe (Out of Memory?)')\n",
            "parameters": [],
            "focused_calls": [
                "send_header"
            ],
            "extend_calls": [
                "def send_response(self, code, message=None):\n        \"\"\"Blanks out default headers\"\"\"\n        self.log_request(code)\n        self.send_response_only(code, message)"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:my_sender:70"
        },
        {
            "function_name": "exploit",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 121,
            "source_code": "    def exploit(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        if not path or path == '/':\n            path = 'index.html'\n        which = unquote(self.path.rsplit('/')[-2])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(EXPLOIT_LOC, which, path), 'rb') as buf:\n            data = buf.read()\n        if path == 'index.html':\n            data = data.replace(b'0.0.0.0', bytes(get_lan(), 'utf-8'))\n        self.my_sender(mime, data)\n",
            "parameters": [],
            "focused_calls": [
                "my_sender"
            ],
            "extend_calls": [
                "def get_lan():\n    \"\"\"Gets the computer's LAN IP\"\"\"\n    soc = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    try:\n        soc.connect(('10.255.255.255', 1))\n        lan = str(soc.getsockname()[0])\n        soc.close()\n    except socket.error:\n        soc.close()\n        closer('ERROR: Unable to find LAN IP')\n\n    return lan",
                "def my_sender(self, mime, content):\n        \"\"\"Here to prevent code duplication\"\"\"\n        try:\n            self.send_response(200)\n            self.send_header('Content-Type', mime)\n            self.send_header('Content-Length', len(content))\n            self.send_header('Connection', 'close')\n            self.end_headers()\n            self.wfile.write(content)\n        except socket.error:\n            print('ERROR: Broken Pipe (Out of Memory?)')"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:exploit:121"
        },
        {
            "function_name": "do_GET",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 187,
            "source_code": "    def do_GET(self):\n        \"\"\"Determines how to handle HTTP requests\"\"\"\n        try:\n            if re.match(r'^\\/update\\/ps4\\/list\\/[a-z]{2}\\/ps4\\-updatelist\\.xml', self.path):\n                self.updatelist()\n            elif re.match(r'^\\/update\\/ps4\\/html\\/[a-z]{2}\\/[a-z]{2}\\/ps4\\-updatefeature\\.html', self.path):\n                self.updatefeature()\n            elif re.match(r'^\\/update\\/ps4\\/image\\/[0-9]{4}_[0-9]{4}\\/(sys|rec)\\_[a-f0-9]{32}\\/PS4UPDATE\\.PUP', self.path):\n                self.update_pup()\n            elif re.match(r'^\\/networktest\\/get\\_2m', self.path):\n                self.network_test(2097152)\n            elif re.match(r'^\\/networktest\\/get\\_6m', self.path):\n                self.network_test(6291456)\n            elif re.match(r'^\\/$', self.path) or re.match(r'^\\/index\\.html', self.path) or re.match(r'^\\/document\\/[a-zA-Z\\-]{2,5}\\/ps4\\/index\\.html', self.path) or re.match(r'^\\/document\\/[a-zA-Z\\-]{2,5}\\/ps4\\/', self.path):\n                if self.check_ua():\n                    self.exploit_matcher()\n                else:\n                    self.send_error(400, explain='This PS4 is not on the right firmware (4.05)')\n                    print('>> Non-4.05 PS4 attempted to access exploits')\n            elif re.match(r'^\\/exploits\\/.*\\/', self.path):\n                if self.check_ua():\n                    self.exploit()\n                else:\n                    self.send_error(400, explain='This PS4 is not on the right firmware (4.05)')\n                    print('>> Non-4.05 PS4 attempted to access exploits')\n            elif re.match(r'^\\/static\\/', self.path):\n                self.static_request()\n            else:\n                self.send_error(404)\n        except IOError:\n            self.send_error(404)\n\n        if self.path.rsplit('/', 1)[-1] == 'rop.js':\n            print('>> Exploit sent...')\n            try:\n                payloads_file = os.path.join(EXPLOIT_LOC, self.path.rsplit('/', 2)[-2], 'nopayloads')\n                if os.path.isfile(payloads_file):\n                    print('>> Exploit does not support payload, skipping payload menu')\n                else:\n                    self.payload_launcher()\n            except (IOError, PermissionError):\n                print('>> ERROR Could not determine if exploit accepts payloads')\n                print('>> Payload menu will be loaded anyway...')\n                time.sleep(3)\n                self.payload_launcher()\n",
            "parameters": [],
            "focused_calls": [
                "exploit"
            ],
            "extend_calls": [
                "def static_request(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(STATIC_LOC, path), 'rb') as buf:\n            data = buf.read()\n        self.my_sender(mime, data)",
                "def updatelist(self):\n        region = self.path.split('/')[4]\n        path = os.path.join(UPDATE_LOC, 'ps4-updatelist.xml')\n        with open(path, 'rb') as buf:\n            xml = buf.read()\n        xml = xml.replace(b'{{REGION}}', bytes(region, 'utf-8'))\n        self.my_sender('application/xml', xml)",
                "def network_test(self, size):\n        data = b'\\0' * size\n        self.my_sender('text/plain', data)",
                "def updatefeature(self):\n        path = os.path.join(HTML_LOC, 'ps4-updatefeature.html')\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        data = self.inject_image_html(data)\n        self.my_sender('text/html', data)",
                "def exploit_matcher(self):\n        with open(os.path.join(HTML_LOC, 'exploits.html'), 'rb') as buf:\n            data = buf.read()\n        data = self.inject_exploit_html(data)\n        self.my_sender('text/html', data)",
                "def check_ua(self):\n        \"\"\"Have to allow 4.05 and 5.05 because the spoofer changes the UA\"\"\"\n        if self.headers['User-Agent'] == 'Mozilla/5.0 (PlayStation 4 4.05) AppleWebKit/537.78 (KHTML, like Gecko)' or \\\n           self.headers['User-Agent'] == 'Mozilla/5.0 (PlayStation 4 5.05) AppleWebKit/537.78 (KHTML, like Gecko)':\n            return True\n        else:\n            return False",
                "def payload_launcher(self):\n        payload_menu = True\n        for thread in threading.enumerate():\n            if thread.name == 'Payload_Brain':\n                payload_menu = False\n\n        if payload_menu:\n            thread = threading.Thread(name='Payload_Brain',\n                                      target=payload_brain,\n                                      args=(self.client_address[0],),\n                                      daemon=True)\n            thread.start()",
                "def exploit(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        if not path or path == '/':\n            path = 'index.html'\n        which = unquote(self.path.rsplit('/')[-2])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(EXPLOIT_LOC, which, path), 'rb') as buf:\n            data = buf.read()\n        if path == 'index.html':\n            data = data.replace(b'0.0.0.0', bytes(get_lan(), 'utf-8'))\n        self.my_sender(mime, data)",
                "def update_pup(self):\n        if 'sys' in self.path:\n            check_update_pup('SYSTEM', '203C76C97F7BE5B881DD0C77C8EDF385')\n            path = 'PS4UPDATE_SYSTEM.PUP'\n        elif 'rec' in self.path:\n            check_update_pup('RECOVERY', '741CFE2F0DEC1BB4663571DE78AE31CF')\n            path = 'PS4UPDATE_RECOVERY.PUP'\n        else:\n            path = ''\n        path = os.path.join(UPDATE_LOC, path)\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        self.my_sender('text/plain', data)"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:do_GET:187"
        }
    ],
    [
        {
            "function_name": "my_sender",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 70,
            "source_code": "    def my_sender(self, mime, content):\n        \"\"\"Here to prevent code duplication\"\"\"\n        try:\n            self.send_response(200)\n            self.send_header('Content-Type', mime)\n            self.send_header('Content-Length', len(content))\n            self.send_header('Connection', 'close')\n            self.end_headers()\n            self.wfile.write(content)\n        except socket.error:\n            print('ERROR: Broken Pipe (Out of Memory?)')\n",
            "parameters": [],
            "focused_calls": [
                "send_header"
            ],
            "extend_calls": [
                "def send_response(self, code, message=None):\n        \"\"\"Blanks out default headers\"\"\"\n        self.log_request(code)\n        self.send_response_only(code, message)"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:my_sender:70"
        },
        {
            "function_name": "static_request",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 137,
            "source_code": "    def static_request(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(STATIC_LOC, path), 'rb') as buf:\n            data = buf.read()\n        self.my_sender(mime, data)\n",
            "parameters": [],
            "focused_calls": [
                "my_sender"
            ],
            "extend_calls": [
                "def my_sender(self, mime, content):\n        \"\"\"Here to prevent code duplication\"\"\"\n        try:\n            self.send_response(200)\n            self.send_header('Content-Type', mime)\n            self.send_header('Content-Length', len(content))\n            self.send_header('Connection', 'close')\n            self.end_headers()\n            self.wfile.write(content)\n        except socket.error:\n            print('ERROR: Broken Pipe (Out of Memory?)')"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:static_request:137"
        },
        {
            "function_name": "do_GET",
            "file_path": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py",
            "line_number": 187,
            "source_code": "    def do_GET(self):\n        \"\"\"Determines how to handle HTTP requests\"\"\"\n        try:\n            if re.match(r'^\\/update\\/ps4\\/list\\/[a-z]{2}\\/ps4\\-updatelist\\.xml', self.path):\n                self.updatelist()\n            elif re.match(r'^\\/update\\/ps4\\/html\\/[a-z]{2}\\/[a-z]{2}\\/ps4\\-updatefeature\\.html', self.path):\n                self.updatefeature()\n            elif re.match(r'^\\/update\\/ps4\\/image\\/[0-9]{4}_[0-9]{4}\\/(sys|rec)\\_[a-f0-9]{32}\\/PS4UPDATE\\.PUP', self.path):\n                self.update_pup()\n            elif re.match(r'^\\/networktest\\/get\\_2m', self.path):\n                self.network_test(2097152)\n            elif re.match(r'^\\/networktest\\/get\\_6m', self.path):\n                self.network_test(6291456)\n            elif re.match(r'^\\/$', self.path) or re.match(r'^\\/index\\.html', self.path) or re.match(r'^\\/document\\/[a-zA-Z\\-]{2,5}\\/ps4\\/index\\.html', self.path) or re.match(r'^\\/document\\/[a-zA-Z\\-]{2,5}\\/ps4\\/', self.path):\n                if self.check_ua():\n                    self.exploit_matcher()\n                else:\n                    self.send_error(400, explain='This PS4 is not on the right firmware (4.05)')\n                    print('>> Non-4.05 PS4 attempted to access exploits')\n            elif re.match(r'^\\/exploits\\/.*\\/', self.path):\n                if self.check_ua():\n                    self.exploit()\n                else:\n                    self.send_error(400, explain='This PS4 is not on the right firmware (4.05)')\n                    print('>> Non-4.05 PS4 attempted to access exploits')\n            elif re.match(r'^\\/static\\/', self.path):\n                self.static_request()\n            else:\n                self.send_error(404)\n        except IOError:\n            self.send_error(404)\n\n        if self.path.rsplit('/', 1)[-1] == 'rop.js':\n            print('>> Exploit sent...')\n            try:\n                payloads_file = os.path.join(EXPLOIT_LOC, self.path.rsplit('/', 2)[-2], 'nopayloads')\n                if os.path.isfile(payloads_file):\n                    print('>> Exploit does not support payload, skipping payload menu')\n                else:\n                    self.payload_launcher()\n            except (IOError, PermissionError):\n                print('>> ERROR Could not determine if exploit accepts payloads')\n                print('>> Payload menu will be loaded anyway...')\n                time.sleep(3)\n                self.payload_launcher()\n",
            "parameters": [],
            "focused_calls": [
                "static_request"
            ],
            "extend_calls": [
                "def static_request(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(STATIC_LOC, path), 'rb') as buf:\n            data = buf.read()\n        self.my_sender(mime, data)",
                "def updatelist(self):\n        region = self.path.split('/')[4]\n        path = os.path.join(UPDATE_LOC, 'ps4-updatelist.xml')\n        with open(path, 'rb') as buf:\n            xml = buf.read()\n        xml = xml.replace(b'{{REGION}}', bytes(region, 'utf-8'))\n        self.my_sender('application/xml', xml)",
                "def network_test(self, size):\n        data = b'\\0' * size\n        self.my_sender('text/plain', data)",
                "def updatefeature(self):\n        path = os.path.join(HTML_LOC, 'ps4-updatefeature.html')\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        data = self.inject_image_html(data)\n        self.my_sender('text/html', data)",
                "def exploit_matcher(self):\n        with open(os.path.join(HTML_LOC, 'exploits.html'), 'rb') as buf:\n            data = buf.read()\n        data = self.inject_exploit_html(data)\n        self.my_sender('text/html', data)",
                "def check_ua(self):\n        \"\"\"Have to allow 4.05 and 5.05 because the spoofer changes the UA\"\"\"\n        if self.headers['User-Agent'] == 'Mozilla/5.0 (PlayStation 4 4.05) AppleWebKit/537.78 (KHTML, like Gecko)' or \\\n           self.headers['User-Agent'] == 'Mozilla/5.0 (PlayStation 4 5.05) AppleWebKit/537.78 (KHTML, like Gecko)':\n            return True\n        else:\n            return False",
                "def payload_launcher(self):\n        payload_menu = True\n        for thread in threading.enumerate():\n            if thread.name == 'Payload_Brain':\n                payload_menu = False\n\n        if payload_menu:\n            thread = threading.Thread(name='Payload_Brain',\n                                      target=payload_brain,\n                                      args=(self.client_address[0],),\n                                      daemon=True)\n            thread.start()",
                "def exploit(self):\n        path = unquote(self.path.rsplit('/', 1)[-1])\n        if not path or path == '/':\n            path = 'index.html'\n        which = unquote(self.path.rsplit('/')[-2])\n        mime = mimetypes.guess_type(path)\n        if mime[0]:\n            mime = mime[0]\n        else:\n            mime = 'application/octet-stream'\n        with open(os.path.join(EXPLOIT_LOC, which, path), 'rb') as buf:\n            data = buf.read()\n        if path == 'index.html':\n            data = data.replace(b'0.0.0.0', bytes(get_lan(), 'utf-8'))\n        self.my_sender(mime, data)",
                "def update_pup(self):\n        if 'sys' in self.path:\n            check_update_pup('SYSTEM', '203C76C97F7BE5B881DD0C77C8EDF385')\n            path = 'PS4UPDATE_SYSTEM.PUP'\n        elif 'rec' in self.path:\n            check_update_pup('RECOVERY', '741CFE2F0DEC1BB4663571DE78AE31CF')\n            path = 'PS4UPDATE_RECOVERY.PUP'\n        else:\n            path = ''\n        path = os.path.join(UPDATE_LOC, path)\n        with open(path, 'rb') as buf:\n            data = buf.read()\n        self.my_sender('text/plain', data)"
            ],
            "conditions_for_focused_calls": {},
            "parameter_conditions": "",
            "is_vulnerability_reachable": false,
            "unique_id": "/PycharmProjects/PyVul/src/context/dataset/test_data/CVE-2024-28237/ps4-exploit-host/start.py:do_GET:187"
        }
    ]
]
